;
; Title:	BBC Basic Interpreter - Z80 version
;		Spectrum Next ULA Graphics Routines
; Author:	Dean Belfield
; Created:	13/05/2021
; Last Updated:	19/05/2021
;
; Modinfo:
; 15/05/2021:	Plot now pulls PLOT_MODE and PLOT_COLOUR direct from RAM; Updates for MODE command
; 17/05/2021:	Tweaks for COLOUR, GCOL
; 19/05/2021:	Fixed bug in Get_Char

			MODULE	NEXT_GRAPHICS_ULA

; Set the video mode up
;
Set_Video_Mode:		NEXTREG 0x15, %00101001		; Enable sprites & clipping, SUL priority
			LD	A, %01000111
			LD	(TEXT_FOREGROUND), A 
			LD	(PLOT_COLOUR), A
			RET

; Clear the screen
;
Clear_Screen:		LD	A, (BORDER_COLOUR)
			OUT	(254), A
			LD	HL,16384		; Start address of screen bitmap
			LD	DE,16385		; Address + 1
			LD	BC,6144			; Length of bitmap memory to clear
			LD	(HL),0			; Set the first byte to 0
			LDIR				; Copy this byte to the second, and so on
			LD	BC,767			; Length of attribute memory, less one to clear
			LD	A, (TEXT_FOREGROUND)
			LD	(HL),A			; Set the first byte to A
			LDIR				; Copy this byte to the second, and so on
			NEXTREG	ULA_Y_SCROLL, 0		; Reset scroll
			RET

; Scroll
;  H: Line to clear after scroll
;
Set_Scroll_Reg:		LD	A, (SCRLPOS_Y)
			ADD	A, A
			ADD	A, A
			ADD	A, A 
			NEXTREG	ULA_Y_SCROLL, A 

; Clear a line
;  H: Line to clear
;
Clear_Line:		LD 	L, 0
			CALL	NEXT_IO.Get_Charpos_1
			CALL	Get_Char_Address
			PUSH	HL
			XOR	A
			LD	C, 8
1:			LD	B, 32
			PUSH	HL			
2:			LD	(HL), A 
			INC	L 
			DJNZ	2B
			POP	HL
			INC	H 
			DEC	C 
			JR	NZ, 1B
			POP	HL 
			LD	A, H 
			RRA
			RRA 
			RRA 
			AND 	3 
			OR	88
			LD	H, A 
			LD	B,32 
			LD	A, (TEXT_FOREGROUND)
3:			LD	(HL), A 
			INC	L 
			DJNZ	3B
			RET 

; Display a cursor at an X/Y position
;  L: X coordinate
;  H: Y coordinate
;  E: Style
;     0: Off
;     1: On
;
Display_Cursor:		CALL	Get_Attr_Address
			LD	A, E 
			CP	0
			LD	A, (TEXT_FOREGROUND)
			JR	Z, 1F
			LD	A, %10111000
1:			LD	(HL), A
			RET

; Print a single character out to an X/Y position
;  E: Character to print
;  L: X Coordinate
;  H: Y Coordinate
;
Print_Char:		CALL 	Get_Char_Address
			LD 	D, 8			; Multiply the character byte by 8
			MUL 	D,E
			LD 	A,0x3C			; Address of character set in ROM (HIGH)
			ADD 	A,D
			LD 	D,A
			LD	B,8			; Loop counter
1:			LD 	A,(DE)			; Get the byte from the character in A
			LD 	(HL),A			; Stick A onto the screen
			INC 	DE			; Goto next byte of character
			INC 	H			; Goto next line on screen
			DJNZ 	1B			; Loop around whilst it is Not Zero (NZ)
			LD	A, H 			; And set the attribute up too
			RRA
			RRA 
			RRA
			DEC	A
			AND 	3 
			OR	88
			LD	H, A 
			LD	A,(TEXT_FOREGROUND)
			LD	(HL), A
			RET

; Gets the ASCII code of a chararcter on-screen
;  L: X Coordinate
;  H: Y Coordinate
; Returns:
;  A: ASCII character, or 0xFF if no match
;  F: C if character match, otherwise NC
;
Get_Char:		CALL	Get_Char_Address	; Get character address in HL
			LD	DE, 0x3D00		; Start of system font
			LD	C, 32 			; ASCII code
0:			LD	B, 8			; Row counter
			PUSH	DE 			; Push the character address
			PUSH	HL			; And the screen address
1:			LD	A, (DE)			; Get first row from charset
			CP	(HL)			; Compare it with screen
			JR	NZ, 2F			; If there is a mismatch, skip..
			INC	H			; Next row on screen
			INC 	DE			; Next row of system font
			DJNZ	1B
			POP	HL			; Pop the screen address
			POP	DE			; Pop the character address
			LD	A, C			; At this point we have a match
			SCF
			RET				; Return the character, Z flag set
2:			POP	HL			; Pop the screen address
			POP	DE			; Pop the character address
			INC	C			; Increment character #
			BIT	7, C 			; If we've reached character 128
			JR 	NZ, 3F			; Then ret wih Z flag not set
			LD	A, 8 
			ADD	DE, A 			; Advance 8 bytes to next character in system font
			JR	0B			; Lather, rinse and repeat
3:			XOR	A 			; Clear carry flag and
			INC	A			; Set A to 0xFF
			RET 

; Get screen address
;  H: Y character position
;  L: X character position
; Returns address in HL
;
Get_Char_Address:	LD	A,H
			AND	%00000111
			RRA
			RRA
			RRA
			RRA
			OR	L
			LD	L,A
			LD	A,H
			AND	%00011000
			OR	%01000000
			LD	H,A
			RET				; Returns screen address in HL

; Get the attribute address
;  H: Y character position
;  L: X character position
; Return address in HL
;
Get_Attr_Address:	PUSH	DE
			LD 	D, 32			; Multiply Y by 32
			LD 	E, H
			LD	A, L			; Get the X offset
			MUL 	D, E 			; Multiply Y by 32
			ADD	DE, A			; Add X
			EX	DE, HL
			LD 	A, H
			ADD 	A, 0x58			; Add the attribute 
			LD 	H, A
			POP	DE
			RET

; Plot a point
;  E: X
;  D: Y
;	
Plot:			LD	A, (PLOT_MODE)		; Check plot mode is valid
			CP	7
			RET	NC			; Do nothing if plot mode >=7
			LD	A, (SCRLPOS_Y)		; Get Y scroll position
			ADD	A, A
			ADD	A, A 
			ADD	A, A 			; Multiply by 8
			ADD	A, D 			; Add to pixel Y position
			JR	C, 0F 			; If we've wrapped, then skip
			CP	192			; Gone off screen?
			JR	C, 1F 
0:			SUB	192
1:			LD	D, A 			; D = Y, E = X
			PIXELAD				; Get the pixel address in HL
			SETAE				; Get pixel mask in A
			LD	E, A 			;  E: Pixel mask
			LD	A, (PLOT_MODE)
			CALL	SWITCH_A
			DEFW	Plot_OR
			DEFW	Plot_OR
			DEFW	Plot_AND
			DEFW	Plot_XOR 
			DEFW	Plot_XOR
			DEFW	Plot_NOP
			DEFW 	Plot_AND 

Plot_NOP:		RET				; Jump to plot routine (address stacked previous)

Plot_OR:		LD	A, (HL)
			OR	E			; OR with screen
			LD	(HL), A
			JR	Plot_Attribute

Plot_AND:		LD	A, E			; AND with screen
			CPL 
			AND	(HL)
			LD	(HL), A 
			JR	Plot_Attribute 

Plot_XOR:		LD	A, (HL)
			XOR	E			; XOR with screen
			LD	(HL), A
			JR	Plot_Attribute 

; Write colour value out to ULA attribute map
; HL: Address in ULA pixel map
;  B: Colour to write out
;			
Plot_Attribute:		LD	A, H 			; Get the attribute address from the screen address
			RRA
			RRA 
			RRA 
			AND 	3 
			OR	88
			LD	H, A 
			LD	A, (PLOT_COLOUR)
			LD	(HL), A			; Write the colour out
			RET

; Calculate Speccy colour for COLOUR and GCOL
;  C: New Colour
;  A: Existing attribute value
; Returns:
;  A: New attribute value
;
Get_Attr_Value:		BIT	7, C		; Check bit 7 of the new colour
			JR	Z, 1F		; for numbers >=128
			AND	%11000111	; And out the PAPER colour
			LD	B, A		; Store in B
			LD	A, C 
			AND	%00000111	; Get colour
			RLA 			; Shift into position
			RLA 
			RLA 
			OR	B 		; Or with existing colour
			RET
1:			AND	%11111000	; And out the INK colour
			LD	B, A		; Store in B
			LD	A, C 
			AND	%00000111	; Get colour
			OR	B 		; Or with existing colour
			RET

; Set the graphics colour
; HL: Value to set
;  C: Colour to set
;  B: Mode
;
Set_Plot_Colour:	LD	HL, PLOT_COLOUR
			JR	Set_Attr

; Set the text colour
; HL: Value to set
;  C: Colour to set
;  B: Mode
;
Set_Text_Colour:	LD	HL, TEXT_FOREGROUND
Set_Attr:		LD 	A, B
			CP	6
			RET	NC
			CALL	SWITCH_A
			DEFW	Set_Attr_All
			DEFW	Set_Attr_Ink
			DEFW	Set_Attr_Paper
			DEFW	NEXT_GRAPHICS.Set_Border
			DEFW	Set_Attr_Bright
			DEFW	Set_Attr_Flash
;
Set_Attr_Paper:		SET	7, C 
			JR	Set_Attr
;
Set_Attr_Ink:		RES	7, C
Set_Attr_All:		LD	A, (HL)
			CALL	Get_Attr_Value
			LD	(HL), A
			RET
;
Set_Attr_Bright:	LD	A, C 
			AND	1 
			RRCA 
			RRCA 
			LD	B, A 
			LD	A, (HL)
			AND	%10111111
			OR	B 
			LD	(HL), A 
			RET
;
Set_Attr_Flash:		LD	A, C 
			AND	1 
			RRCA 
			LD	B, A 
			LD	A, (HL)
			AND	%01111111
			OR	B 
			LD	(HL), A 
			RET

			ENDMODULE