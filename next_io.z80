;
; Title:	BBC Basic Interpreter - Z80 version
;		Spectrum Next I/O Routines
; Author:	Dean Belfield
; Created:	03/05/2021
; Last Updated:	10/05/2021
;
; Modinfo:
; 10/05/2021:	Started implementing VDU engine
;
			MODULE	NEXT_IO

; Clear the screen
;
Clear_Screen:		LD 	A, (TEXT_COLOUR)
			LD	HL,16384		; Start address of screen bitmap
			LD	DE,16385		; Address + 1
			LD	BC,6144			; Length of bitmap memory to clear
			LD	(HL),0			; Set the first byte to 0
			LDIR				; Copy this byte to the second, and so on
			LD	BC,767			; Length of attribute memory, less one to clear
			LD	(HL),A			; Set the first byte to A
			LDIR				; Copy this byte to the second, and so on
			XOR	A 
			LD	(SCRLPOS_Y), A 
			NEXTREG	ULA_Y_SCROLL, A 
			RET

; Read the keyboard and return an ASCII character code
; Returns:
;  A: 0x00 if no key pressed
;
Read_Keyboard:		PUSH	BC
			PUSH	DE
			PUSH	HL
			CALL	1F
			POP	HL
			POP	DE
			POP	BC
			RET
1:			CALL	Keyscan			; Scan the keyboard
			LD	A, E			; Check for keypress
			INC	A			; Check for 0xFF
			RET	Z			; Then no key has been pressed
			DEC	A
			LD	HL, KeyTable_Main	; Lookup the key value
			ADD 	HL, A
			LD	A, (HL)			; Fetch the key value

			CP	"A"			; Is it a letter?
			JR	C, 3F			; No, so skip

			BIT	1, D 			; Has symbol shift been pressed?
			JR	NZ, 2F			; Yes, so get the shifted value
			LD	E, A			; Store the keypress
			LD	A, (FLAGS)		; Get caps lock flag
			AND	%00100000
			XOR	E
			BIT	0, D			; Has caps shift been pressed
			RET	Z			; No, so just return the letter
			XOR	%00100000		; Switch case
			RET
;
; It's a symbol shifted letter at this point
;
2:			SUB	"A"
			LD	HL, KeyTable_SS_Alpha	; Get the key value
			ADD	HL, A 
			LD	A, (HL)			; Get the character code
			RET
;
; It's not a letter at this point, but could be space or enter
;
3:			BIT	0, D 			; Check for caps
			JR	NZ, 4F			; If pressed, we'll check for special cases
			BIT	1, D			; Has symbol shift been pressed
			RET	Z			; No, so just return the number
			SUB	"0"			; Index from ASCII '0'
			LD	HL, KeyTable_SS_Numeric
			ADD	HL, A
			LD	A, (HL)
			RET
;
; Special cases, like escape, etc. Caps shift is pressed here
;
4:			CP	" "			; Caps Shift + Space
			JR	NZ, 5F 
			LD	A, 0x1B			; Return ESC
			RET 
5:			CP	"0"			; Caps Shift + 0
			JR	NZ, 6F
			LD	A, 0x7F			; Return DEL
			RET 
6:			CP	"2"			; Caps Shift + 2
			RET	NZ
			LD	A, (FLAGS)		; Toggle Caps Lock bit in flags
			XOR	%00100000
			LD	(FLAGS), A
			XOR	A
			RET

; Get adjusted charpos (takes scrollpos into account)
;
Get_Charpos		LD	HL, (CHARPOS_X)
Get_Charpos_1:		PUSH	AF
			LD	A,(SCRLPOS_Y)
			ADD	A, H 
			CP	24
			JR	C, 1F 
			SUB	24
1:			LD	H, A
			POP	AF
			RET
 
; Print a character at the current charpos
;
Print_Char:		PUSH	BC 			; Stack all the registers
			PUSH	DE
			PUSH	HL
			CALL	1F			; Call the print routine
			POP	HL 
			POP	DE 
			POP	BC
			RET 

1:			LD	C, A			; Temporarily store the character
			LD	A, (VDU_STATE)		; What's the current VDU state?
			OR	A 			; If not zero...
			JR	NZ, VDU_READ_BYTES	; Read the data into the VDU buffer and don't output
			LD	A, C			; Get the character code back
			CP	32			; Is the character a control routine?
			JR	C, VDU_CTRL_CHAR	; Yes, so just handle that
			CP	0x7F			; Is it backspace?
			JR	Z, VDU_DEL 		; Yes, so deal with that
			CALL	Get_Charpos		; Otherwise print it out		
			CALL	ULA_Print_Char_At
			LD	A, H 			; And set the attribute up too
			RRA
			RRA 
			RRA 
			AND 	3 
			OR	88
			LD	H, A 
			LD	A,(TEXT_COLOUR)
			LD	(HL), A
			JP	VDU_HT

; Handle all control characters
;  A: Character code
;  C: Character code (copied in Print_Char)
;
VDU_CTRL_CHAR:		ADD	A, A			; Index into the VDU table
			LD	HL, TABLE_VDU
			ADD	HL, A 
			LD	A, (HL)
			INC	HL 
			LD	H, (HL) 
			LD	L, A 			; Get the jmup address
			LD	A, C 			; Get the character back in A
			JP	(HL)			; And jump to the correct routine

; &7F DEL - Delete
;
VDU_DEL:		CALL	VDU_BS
			LD	A, " "
			CALL	Get_Charpos
			JP	ULA_Print_Char_At

; Just buffer the characters in the VDU buffer
; Until we have read enough in, then execute the relevant code
;
VDU_READ_BYTES:		LD	HL, VDU_BUFFER		; HL: VDU buffer
			LD	A, (VDU_PTR)		; A: Current position in buffer
			ADD	HL, A 			; Index in
			LD	(HL), C			; Store the character
			INC	A 			; Increment the pointer
			LD	(VDU_PTR), A 		; And store
			LD	A, (VDU_COUNT)		; Decrement the VDU count; this is the number
			DEC	A 			; of chars left to read before we return VDU_STATE
			LD	(VDU_COUNT), A 		; back to 0 and execute the VDU command
			RET	NZ			; If not zero, then return
			LD	A, (VDU_STATE)		; Get the correct handler for this state
			DEC	A 			; Index from 0
			ADD	A, A
			LD	HL, TABLE_VDU_EXEC	; by looking it up in TABLE_VDU_EXEC
			ADD	HL, A 
			LD	A, (HL)
			INC	HL 
			LD	H, (HL)
			LD	L, A 
			XOR	A 
			LD	(VDU_STATE), A		; Reset the VDU state
			JP 	(HL)
			
; Lookup table of VDU_EXEC routines
;
TABLE_VDU_EXEC:		DW	VDU_EXEC_PLOT
			DW	VDU_EXEC_COLOUR
			DW	VDU_EXEC_GCOL 
			DW	VDU_EXEC_TAB 

; PLOT: VDU 25,mode,x;y;
;
VDU_EXEC_PLOT:		LD	A, (VDU_BUFFER + 0)	; Plot style in B
			LD	B, A
			LD	A, (PLOT_MODE) 	
			LD	C, A			; Plot mode in C
			LD	A, (PLOT_COLOUR)
			LD	DE, (VDU_BUFFER + 1)
			LD	HL, (VDU_BUFFER + 3)
			JP	NEXT_GRAPHICS.Plot

; COLOUR: VDU 17,colour
;
VDU_EXEC_COLOUR:	LD	A, (VDU_BUFFER + 0)
			LD	L, A
			LD	A, (TEXT_COLOUR)
			CALL	Get_ULA_Colour
			LD	(TEXT_COLOUR), A
			RET 

; GCOL: VDU 18,mode,,colour
;
VDU_EXEC_GCOL:		LD	A, (VDU_BUFFER + 0)
			LD	(PLOT_MODE), A 
			LD	A, (VDU_BUFFER + 1)
			LD	L, A 
			LD	A, (PLOT_COLOUR)
			CALL	Get_ULA_Colour
			LD	(PLOT_COLOUR), A
			RET 

; TAB: VDU 31,x,y
;
VDU_EXEC_TAB:		LD	A, (VDU_BUFFER + 0)
			LD 	(CHARPOS_X), A 
			LD	A, (VDU_BUFFER + 1)
			LD	(CHARPOS_Y), A
			RET 

; Lookup table of VDU codes
;
TABLE_VDU:		DW 	VDU_NUL			; &00 NUL - Do nothing
			DW	VDU_NUL			; &01 SOH - Send next character to printer only
			DW	VDU_NUL			; &02 STX - Start print job
			DW	VDU_NUL			; &03 ETX - End print job
			DW	VDU_NUL			; &04 EOT - Write text at text cursor
			DW	VDU_NUL			; &05 ENQ - Write text at graphics cursor
			DW	VDU_NUL			; &06 ACK - Enable VDU drivers
			DW	VDU_NUL			; &07 BEL - Make a short beep
			DW	VDU_BS			; &08 BS  - Backspace
			DW	VDU_HT			; &09 HT  - Advance cursor one character
			DW	VDU_LF			; &0A LF  - Move cursor down one line
			DW	VDU_VT			; &0B VT  - Move cursor up one line
			DW	VDU_FF			; &0C FF  - Clear text area (CLS)
			DW	VDU_CR			; &0D CR  - Move cursor to start of current line
			DW	VDU_NUL			; &0E SO  - Page mode on
			DW	VDU_NUL			; &0F SI  - Page mode off
			DW	VDU_NUL			; &10 DLE - Clear graphcs area (CLG)
			DW	VDU_DC1			; &11 DC1 - Define text colour (COLOR n)
			DW	VDU_DC2			; &12 DC2 - Define graphics colour (GCOL a, n)
			DW	VDU_NUL			; &13 DC3 - Define logical colour (COLOUR l, p)
			DW	VDU_NUL			; &14 DC4 - Restore logical colours
			DW	VDU_NUL			; &15 NAK - Disable VDU drivers or delete current line
			DW	VDU_NUL			; &16 SYN - Select screen mode (MODE n)
			DW	VDU_NUL			; &17 ETB - Define display character and other commands; used by ON and OFF
			DW	VDU_NUL			; &18 CAN - Define graphics windows
			DW	VDU_EM			; &19 EM  - PLOT k, x, y (used by MOVE, DRAW, etc)
			DW	VDU_NUL			; &1A SUB - Restore default windows
			DW	VDU_NUL			; &1B ESC - Does nothing
			DW	VDU_NUL			; &1C FS  - Define text window
			DW	VDU_NUL			; &1D GS  - Define graphics origin (ORIGIN)
			DW	VDU_RS			; &1E RS  - Home
			DW	VDU_US			; &1F US  - Move text cursor to X, Y (PRINT TAB(x,y));

; &00 NUL - Do nothing
;
VDU_NUL:		RET 

; &08 BS  - Backspace
; 
VDU_BS:			LD	A, (CHARPOS_X)
			OR	A
			RET	Z
			DEC	A 
			LD	(CHARPOS_X), A 
			RET 

; &09: HT  - Advance to next character
;
VDU_HT:			LD	A, (CHARPOS_X)
			INC	A
			LD	(CHARPOS_X), A 
			CP	32
			RET 	C 
			CALL	VDU_CR

; &0A LF  - Linefeed
;
VDU_LF:			LD	A, (CHARPOS_Y)
			INC	A 
			LD	(CHARPOS_Y), A 
			CP	24 
			RET 	C 
1:			LD	A, 23
			LD	(CHARPOS_Y), A
			JP 	Scroll_Up

; &0B VT  - Move cursor up one line
;
VDU_VT:			LD	A, (CHARPOS_Y)
			DEC	A 
			LD	(CHARPOS_Y), A 
			RET 	P 
			XOR	A 
			LD	(CHARPOS_Y), A 
			JP	Scroll_Down

; &0C FF  - CLS
;
VDU_FF:			CALL	VDU_RS
			JP 	Clear_Screen


; &0D CR  - Carriage Return
;
VDU_CR:			XOR	A 
			LD 	(CHARPOS_X), A
			RET 

; &11 DC1 - COLOR n
;
VDU_DC1:		LD	B, 1			; 1 byte (colour)
			LD	A, 2 			; State 2: COLOUR
			JR	VDU_SET_STATE

; &12 DC2 - GCOL a, n
;
VDU_DC2:		LD	B, 2 			; 2 bytes (mode, colour)
			LD	A, 3 			; State 3: GCOL
			JR	VDU_SET_STATE

; &19 EM  - PLOT k, x, y
;
VDU_EM:			LD	B, 5			; 5 bytes (mode, xl, xh, yl, yh)
			LD	A, 1			; State 1: PLOT
			JR	VDU_SET_STATE

; &1E RS  - HOME
;
VDU_RS:			XOR	A
			LD 	(CHARPOS_X), A 
			LD	(CHARPOS_Y), A
			RET

; &1F US  - PRINT TAB(x,y);
;
VDU_US:			LD	B, 2			; 2 bytes (x, y)
			LD	A, 4			; State 4: TAB
			JR	VDU_SET_STATE

; Set up the VDU engine to redirect characters into VDU_BUFFER
;  A: Code for the state (the VDU character that initialised it, i.e. 25 for PLOT
;  B: Number of bytes to read before executing the state, i.e. 5 for PLOT
;
VDU_SET_STATE:		LD	(VDU_STATE), A
			LD	A, B
			LD	(VDU_COUNT), A 
			XOR	A 
			LD	(VDU_PTR), A 
			RET 

; Next hardware scroll down
;
Scroll_Down:		LD	A, (SCRLPOS_Y)
			DEC 	A 
			RET	P
			LD	A, 23
			JR	3F

; Next hardware scroll up
;
Scroll_Up:		LD	A, (SCRLPOS_Y)
			INC	A 
			CP	24
			JR	C, 3F
			XOR	A 
3:			LD	(SCRLPOS_Y), A 
			SLA	A 
			SLA 	A 
			SLA 	A 
			NEXTREG	ULA_Y_SCROLL, A 
			LD	A, (CHARPOS_Y)

; Clear a line
;  A: Line to clear
;
Clear_Line:		LD	H, A
			LD 	L, 0
			CALL	Get_Charpos_1
			CALL	ULA_Get_Char_Address
			PUSH	HL
			XOR	A
			LD	C, 8
1:			LD	B, 32
			PUSH	HL			
2:			LD	(HL), A 
			INC	L 
			DJNZ	2B
			POP	HL
			INC	H 
			DEC	C 
			JR	NZ, 1B
			POP	HL 
			LD	A, H 
			RRA
			RRA 
			RRA 
			AND 	3 
			OR	88
			LD	H, A 
			LD	B,32 
			LD	A, (TEXT_COLOUR)
3:			LD	(HL), A 
			INC	L 
			DJNZ	3B
			RET 

; Get screen address
; H = Y character position
; L = X character position
; Returns address in HL
;
ULA_Get_Char_Address:	LD	A,H
			AND	%00000111
			RRA
			RRA
			RRA
			RRA
			OR	L
			LD	L,A
			LD	A,H
			AND	%00011000
			OR	%01000000
			LD	H,A
			RET				; Returns screen address in HL

; Print a single character out to an X/Y position
;  A: Character to print
;  L: X Coordinate
;  H: Y Coordinate
;
ULA_Print_Char_At:	PUSH 	AF
			CALL 	ULA_Get_Char_Address
			POP 	AF			; Fall through to Print_Char

; Print a single character out to a screen address
;  A:  Character to print
; HL: Screen address to print character at
; No SM code here - needs to be re-enterent if called on interrupt
;
ULA_Print_Char:		PUSH 	HL
			LD 	D, 8			; Multiply the character byte by 8
			LD 	E, A
			MUL 	D,E
			LD 	A,0x3C			; Address of character set in ROM (HIGH)
			ADD 	A,D
			LD 	D,A
			CALL 	ULA_Print_UDG8
			POP 	HL
			RET 	

; Print a UDG (Single Height)
; DE - Character data
; HL - Screen address
;
ULA_Print_UDG8:		LD	B,8			; Loop counter
1:			LD 	A,(DE)			; Get the byte from the character in A
			LD 	(HL),A			; Stick A onto the screen
			INC 	DE			; Goto next byte of character
			INC 	H			; Goto next line on screen
			DJNZ 	1B			; Loop around whilst it is Not Zero (NZ)
			RET


; Scan the keyboard
; A modified version of the ZX Spectum 48K rom routine
; Returns:
;  E: Keycode (in the range 0 to 39), or 0xFF if no key pressed
;  D: Shift code - bit 0: caps, bit 1: symbol
;
Keyscan:		LD	L,  0x2F		; The initial key value for each line
			LD	DE, 0xFFFF		; Initialise DE to no-key
			LD	BC, 0xFEFE		; C = port address, B = counter
1:			IN	A, (C)			; Read bits from keyboard port
			CPL 
			AND	0x1F
			JR	Z, Keyscan_Done
			LD	H, A 			; Key bits go to the H register
			LD	A, L 			; Fetch initial key value
Keyscan_Multiple:	INC	D			; If three keys pressed, D will no longer contain FF
			RET	NZ			; So return at that point
2:			SUB	8			; Loop until we find a key
			SRL	H 
			JR	NC, 2B
			LD	D, E			; Copy any earlier key found to D
			LD	E, A			; And store the new key value in E
			JR	NZ, Keyscan_Multiple	; Loop if there are more keys
Keyscan_Done:		DEC	L			; Line has been scanned, so reduce initial key value for next pass
			RLC	B 			; Shift the counter
			JR	C, 1B			; And loop if there are still lines to be scanned
			INC	D			; If D = 0xFF, then single key pressed
			RET	Z
			DEC	D
			LD	A, E			; Symbol shift could be in E as code 0x18
			CP	0x18			
			JR 	NZ, 3F
			LD	E, D			; If it is, fetch the keycode from D
			LD	D, 0x18			; And set D to symbol shift code
3:			LD	A, D			; Get shift key value in D
			LD	D, 0			; Reset shift flags
			CP	0x27			; Check for caps shift
			JR	NZ, 4F			; Skip if not pressed
			SET	0, D 			; Set caps shift flag
4:			CP	0x18			; Check for symbol shift
			RET	NZ			; Skip if not pressed
			SET	1, D 			; Set symbol shift flag
			RET 

KeyTable_Main:		DB	"B", "H", "Y", "6", "5", "T", "G", "V"
			DB	"N", "J", "U", "7", "4", "R", "F", "C"
			DB	"M", "K", "I", "8", "3", "E", "D", "X"
			DB	$00, "L", "O", "9", "2", "W", "S", "Z"
			DB	$20, $0D, "P", "0", "1", "Q", "A", $00

KeyTable_SS_Numeric:	DB 	"_", "!", "@", "#", "$", "%", "&", "'", "(", ")"
KeyTable_SS_Alpha:	DB	"~", "*", "?", $5C
			DB	$00, "{", "}", "^"
			DB	$00, "-", "+", "="
			DB	".", ",", ";", $22
			DB	$7F, "<", "|", ">"
			DB	"]", "/", $00, $60
			DB	"[", ":"

			ENDMODULE
