;
; Title:	BBC Basic Interpreter - Z80 version
;		Spectrum Next I/O Routines
; Author:	Dean Belfield
; Created:	03/05/2021
; Last Updated:	03/05/2021
;
; Modinfo:
;
			MODULE	NEXT_IO

; Clear the screen
;
Clear_Screen:		LD 	A, (TEXT_COLOUR)
			LD	HL,16384		; Start address of screen bitmap
			LD	DE,16385		; Address + 1
			LD	BC,6144			; Length of bitmap memory to clear
			LD	(HL),0			; Set the first byte to 0
			LDIR				; Copy this byte to the second, and so on
			LD	BC,767			; Length of attribute memory, less one to clear
			LD	(HL),A			; Set the first byte to A
			LDIR				; Copy this byte to the second, and so on
			XOR	A 
			LD	(SCRLPOS_Y), A 
			NEXTREG	ULA_Y_SCROLL, A 
			RET

; Read the keyboard and return an ASCII character code
; Returns:
;  A: 0x00 if no key pressed
;
Read_Keyboard:		PUSH	BC
			PUSH	DE
			PUSH	HL
			CALL	1F
			POP	HL
			POP	DE
			POP	BC
			RET
1:			CALL	Keyscan			; Scan the keyboard
			LD	A, E			; Check for keypress
			INC	A			; Check for 0xFF
			RET	Z			; Then no key has been pressed
			DEC	A
			LD	HL, KeyTable_Main	; Lookup the key value
			ADD 	HL, A
			LD	A, (HL)			; Fetch the key value

			CP	"A"			; Is it a letter?
			JR	C, 3F			; No, so skip

			BIT	1, D 			; Has symbol shift been pressed?
			JR	NZ, 2F			; Yes, so get the shifted value
			LD	E, A			; Store the keypress
			LD	A, (FLAGS)		; Get caps lock flag
			AND	%00100000
			XOR	E
			BIT	0, D			; Has caps shift been pressed
			RET	Z			; No, so just return the letter
			XOR	%00100000		; Switch case
			RET
;
; It's a symbol shifted letter at this point
;
2:			SUB	"A"
			LD	HL, KeyTable_SS_Alpha	; Get the key value
			ADD	HL, A 
			LD	A, (HL)			; Get the character code
			RET
;
; It's not a letter at this point, but could be space or enter
;
3:			BIT	0, D 			; Check for caps
			JR	NZ, 4F			; If pressed, we'll check for special cases
			BIT	1, D			; Has symbol shift been pressed
			RET	Z			; No, so just return the number
			SUB	"0"			; Index from ASCII '0'
			LD	HL, KeyTable_SS_Numeric
			ADD	HL, A
			LD	A, (HL)
			RET
;
; Special cases, like escape, etc. Caps shift is pressed here
;
4:			CP	" "			; Caps Shift + Space
			JR	NZ, 5F 
			LD	A, 0x1B			; Return ESC
			RET 
5:			CP	"0"			; Caps Shift + 0
			JR	NZ, 6F
			LD	A, 0x08			; Return Backspace
			RET 
6:			CP	"2"			; Caps Shift + 2
			RET	NZ
			LD	A, (FLAGS)		; Toggle Caps Lock bit in flags
			XOR	%00100000
			LD	(FLAGS), A
			XOR	A
			RET

; Get adjusted charpos (takes scrollpos into account)
;
Get_Charpos		LD	HL, (CHARPOS_X)
Get_Charpos_1:		PUSH	AF
			LD	A,(SCRLPOS_Y)
			ADD	A, H 
			CP	24
			JR	C, 1F 
			SUB	24
1:			LD	H, A
			POP	AF
			RET
 
; Print a character at the current charpos
;
Print_Char:		PUSH	BC 
			PUSH	DE
			PUSH	HL
			CALL	Print_Char_1
			POP	HL 
			POP	DE 
			POP	BC
			RET 
Print_Char_1:		CALL	Get_Charpos
			CP	32
			JR	C, Print_Char_Ctrl
				
			CALL	ULA_Print_Char_At
			LD	A, H 
			RRA
			RRA 
			RRA 
			AND 	3 
			OR	88
			LD	H, A 
			LD	A,(TEXT_COLOUR)
			LD	(HL), A


Print_Char_NC:		LD	A, (CHARPOS_X)
			INC	A
			LD	(CHARPOS_X), A 
			CP	32
			RET 	C 

Print_Char_NL:		XOR	A 
			LD 	(CHARPOS_X), A
			LD	A, (CHARPOS_Y)
			INC	A 
			LD	(CHARPOS_Y), A 
			CP	24 
			RET 	C 

Print_Char_Scroll:	LD	A, 23
			LD	(CHARPOS_Y), A
			JP 	Scroll_Up

Print_Char_Ctrl:	CP	0x0D
			JR	Z, Print_Char_NL 
			CP	0x08
			JR	Z, Print_Char_Backspace
			RET 

Print_Char_Backspace:	LD	A, (CHARPOS_X)
			OR	A
			JR	Z, 1F
			DEC	A 
			LD	(CHARPOS_X), A 
1:			LD	A, " "
			CALL	Get_Charpos
			JP	ULA_Print_Char_At

; Next hardware scroll
;
Scroll_Up:		LD	A, (SCRLPOS_Y)
			INC	A 
			CP	24
			JR	C, 3F
			XOR	A 
3:			LD	(SCRLPOS_Y), A 
			SLA	A 
			SLA 	A 
			SLA 	A 
			NEXTREG	ULA_Y_SCROLL, A 
			LD	A, (CHARPOS_Y)
			LD	H, A
			LD 	L, 0
			CALL	Get_Charpos_1
			CALL	ULA_Get_Char_Address
			PUSH	HL
			XOR	A
			LD	C, 8
1:			LD	B, 32
			PUSH	HL			
2:			LD	(HL), A 
			INC	L 
			DJNZ	2B
			POP	HL
			INC	H 
			DEC	C 
			JR	NZ, 1B
			POP	HL 
			LD	A, H 
			RRA
			RRA 
			RRA 
			AND 	3 
			OR	88
			LD	H, A 
			LD	B,32 
			LD	A, (TEXT_COLOUR)
3:			LD	(HL), A 
			INC	L 
			DJNZ	3B
			RET 

; Get screen address
; H = Y character position
; L = X character position
; Returns address in HL
;
ULA_Get_Char_Address:	LD	A,H
			AND	%00000111
			RRA
			RRA
			RRA
			RRA
			OR	L
			LD	L,A
			LD	A,H
			AND	%00011000
			OR	%01000000
			LD	H,A
			RET				; Returns screen address in HL

; Print a single character out to an X/Y position
;  A: Character to print
;  L: X Coordinate
;  H: Y Coordinate
;
ULA_Print_Char_At:	PUSH 	AF
			CALL 	ULA_Get_Char_Address
			POP 	AF			; Fall through to Print_Char

; Print a single character out to a screen address
;  A:  Character to print
; HL: Screen address to print character at
; No SM code here - needs to be re-enterent if called on interrupt
;
ULA_Print_Char:		PUSH 	HL
			LD 	D, 8			; Multiply the character byte by 8
			LD 	E, A
			MUL 	D,E
			LD 	A,0x3C			; Address of character set in ROM (HIGH)
			ADD 	A,D
			LD 	D,A
			CALL 	ULA_Print_UDG8
			POP 	HL
			RET 	

; Print a UDG (Single Height)
; DE - Character data
; HL - Screen address
;
ULA_Print_UDG8:		LD	B,8			; Loop counter
1:			LD 	A,(DE)			; Get the byte from the character in A
			LD 	(HL),A			; Stick A onto the screen
			INC 	DE			; Goto next byte of character
			INC 	H			; Goto next line on screen
			DJNZ 	1B			; Loop around whilst it is Not Zero (NZ)
			RET


; Scan the keyboard
; A modified version of the ZX Spectum 48K rom routine
; Returns:
;  E: Keycode (in the range 0 to 39), or 0xFF if no key pressed
;  D: Shift code - bit 0: caps, bit 1: symbol
;
Keyscan:		LD	L,  0x2F		; The initial key value for each line
			LD	DE, 0xFFFF		; Initialise DE to no-key
			LD	BC, 0xFEFE		; C = port address, B = counter
1:			IN	A, (C)			; Read bits from keyboard port
			CPL 
			AND	0x1F
			JR	Z, Keyscan_Done
			LD	H, A 			; Key bits go to the H register
			LD	A, L 			; Fetch initial key value
Keyscan_Multiple:	INC	D			; If three keys pressed, D will no longer contain FF
			RET	NZ			; So return at that point
2:			SUB	8			; Loop until we find a key
			SRL	H 
			JR	NC, 2B
			LD	D, E			; Copy any earlier key found to D
			LD	E, A			; And store the new key value in E
			JR	NZ, Keyscan_Multiple	; Loop if there are more keys
Keyscan_Done:		DEC	L			; Line has been scanned, so reduce initial key value for next pass
			RLC	B 			; Shift the counter
			JR	C, 1B			; And loop if there are still lines to be scanned
			INC	D			; If D = 0xFF, then single key pressed
			RET	Z
			DEC	D
			LD	A, E			; Symbol shift could be in E as code 0x18
			CP	0x18			
			JR 	NZ, 3F
			LD	E, D			; If it is, fetch the keycode from D
			LD	D, 0x18			; And set D to symbol shift code
3:			LD	A, D			; Get shift key value in D
			LD	D, 0			; Reset shift flags
			CP	0x27			; Check for caps shift
			JR	NZ, 4F			; Skip if not pressed
			SET	0, D 			; Set caps shift flag
4:			CP	0x18			; Check for symbol shift
			RET	NZ			; Skip if not pressed
			SET	1, D 			; Set symbol shift flag
			RET 

KeyTable_Main:		DB	"B", "H", "Y", "6", "5", "T", "G", "V"
			DB	"N", "J", "U", "7", "4", "R", "F", "C"
			DB	"M", "K", "I", "8", "3", "E", "D", "X"
			DB	$00, "L", "O", "9", "2", "W", "S", "Z"
			DB	$20, $0D, "P", "0", "1", "Q", "A", $00

KeyTable_SS_Numeric:	DB 	"_", "!", "@", "#", "$", "%", "&", "'", "(", ")"
KeyTable_SS_Alpha:	DB	"~", "*", "?", $5C
			DB	$00, "{", "}", "^"
			DB	$00, "-", "+", "="
			DB	".", ",", ";", $22
			DB	$7F, "<", "|", ">"
			DB	"]", "/", $00, $60
			DB	"[", ":"

			ENDMODULE
