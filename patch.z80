;
; Title:	BBC Basic Interpreter - Z80 version
;		Patch file for Spectrum Next
; Author:	Dean Belfield
; Created:	02/05/2021
; Last Updated:	15/06/2021
;
; Modinfo:
; 09/05/2021E:	Fixed plot mode and bug in COMDS table
; 10/05/2021:	Added RTC TIME$ and *TIME, moved some code into misc.z80, and changes due to VDU support
; 15/05/2021:	References to ASC_TO_HEX changed to ASC_TO_NUMBER in STAR commands; Updates for MODE command
; 17/05/2021:	Fixed bug in OSLINE; now returns 0; Added cursor to OSLINE; Added *EDIT; Tweaks for COLOUR, GCOL
; 18/05/2021:	Moved editor code into editor.z80
; 20/05/2021:	Fixed bugs in MOVE and PLOT
; 22/05/2021:	Fixed bugs in DRAW and OSKEY; Minor optimisations
; 23/05/2021:	Implemented *. and *CD 
; 24/05/2021:	Implemented OSLOAD and OSSAVE
; 25/05/2021:	Implemented more file IO commands
; 29/05/2021:	Bug fixes; Implemented *BYE
; 04/06/2021:	Added SOUND
; 08/06/2021:	Tweaked OSLINE EQU to reflect new module name
; 15/06/2021:	Plot, Draw, Move and Line now call Transform_Coords

			MODULE PATCH

@GETIMS:		EQU	NEXT_RTC.GET_DATE_STRING	; Get the time string from the real-time clock module
@OSWRCH:		EQU	NEXT_IO.Print_Char		; Write a character out
@OSLINE			EQU 	EDITOR.Edit_Line		; Line editor

; MODE n: Set video mode
;
@MODE:			CALL    EXPRI
			EXX
			LD	A, L
			CALL	NEXT_GRAPHICS.Set_Video_Mode
			JP	XEQ

; CLG: clear the graphics screen
;
@CLG:			LD	A, 0x10
			CALL	OSWRCH 
			JP	XEQ

; CLRSCN: clears the screen.
;
@CLRSCN:		LD	A, 0x0C
			JP	OSWRCH

; PUTIME: set current time to DE:HL, in centiseconds.
;
@PUTIME:		LD	(TIME + 2), DE
			LD	(TIME + 0), HL
			RET

; GETIME: return current time in DE:HL, in centiseconds.
;
@GETIME:		LD	DE, (TIME + 2)
 	  		LD	HL, (TIME + 0)
			RET

; PUTCSR: move to cursor to x=DE, y=HL
;
@PUTCSR:		PUSH	AF 
			LD	A, E
			LD	(CHARPOS_X), A 
			LD	A, D 
			LD	(CHARPOS_Y), A 
			POP	AF
			RET

; GETCSR: return cursor position in x=DE, y=HL
;
@GETCSR:		PUSH	AF
			LD	D, 0
			LD	H, D
			LD	A,(CHARPOS_X)
			LD	E, A
			LD 	A,(CHARPOS_Y)
			LD	L, A
			POP	AF
			RET

; Read character from keyboard (blocking)
;
@OSRDCH:		LD	A, (KEYCODE)	; Read keyboard
			OR	A 		
			JR	Z, OSRDCH	; Loop until key is pressed
			PUSH	AF
1:			LD	A, (KEYCODE)	; And same again
			OR	A 
			JR	NZ, 1B 		; But loop until key is released
			POP 	AF  		; Return the keycode
			RET

; PROMPT: output the input prompt
;
@PROMPT: 		LD	A,'>'
			JP	OSWRCH

;OSKEY - Read key with time-limit, test for ESCape.
;Main function is carried out in user patch.
;   Inputs: HL = time limit (centiseconds)
;  Outputs: Carry reset if time-out
;           If carry set A = character
; Destroys: A,H,L,F
;
@OSKEY:			LD	A, (KEYCODE)	; Read keyboard
			OR	A		; If we have a character
			JR	NZ, 1F		; Then process it
			LD	A,H		; Check if HL is 0 (this is passed by INKEY() function
			OR	L
			RET	Z 		; If it is then ret
			HALT			; Bit of a bodge so this is timed in ms
			DEC	HL 		; Decrement the counter and 
			JR	@OSKEY 		; loop
1:			CP	0x1B		; If we are not pressing ESC, 
			SCF 			; then flag we've got a character
			RET	NZ		
;
ESCSET: 		PUSH    HL
        		LD      HL,FLAGS
        		BIT     6,(HL)          ; ESC DISABLED?
        		JR      NZ,ESCDIS
        		SET     7,(HL)          ; SET ESCAPE FLAG
ESCDIS: 		POP     HL
        		RET	
;
ESCTEST:		LD	A, (KEYCODE)
			CP	0x1B		; ESC	
			JR	Z,ESCSET
			RET
;
@TRAP:			CALL	ESCTEST
@LTRAP:			LD	A,(FLAGS)
			OR	A
			RET	P
			LD	HL,FLAGS 
			RES	7,(HL)
			JP	ESCAPE

;OSINIT - Initialise RAM mapping etc.
;If BASIC is entered by BBCBASIC FILENAME then file
;FILENAME.BBC is automatically CHAINed.
;   Outputs: DE = initial value of HIMEM (top of RAM)
;            HL = initial value of PAGE (user program)
;            Z-flag reset indicates AUTO-RUN.
;  Destroys: A,D,E,H,L,F
;
@OSINIT: 		XOR	A
			LD	(@FLAGS), A		; Clear flags
         		LD 	DE, IM2_Table - 256	; DE = HIMEM (currently under IM2 table)
         		LD 	HL, @USER
         		RET	

;OSCLI - Process an "operating system" command
;
@OSCLI: 		CALL    SKIPSP
			CP      CR
			RET     Z
			CP      '|'
			RET     Z
			CP      '.'
			JP      Z,STAR_DOT	; *.
			EX      DE,HL
			LD      HL,COMDS
OSCLI0:			LD      A,(DE)
			CALL    UPPRC
			CP      (HL)
			JR      Z,OSCLI2
			JR      C,HUH
OSCLI1:			BIT     7,(HL)
			INC     HL
			JR      Z,OSCLI1
			INC     HL
			INC     HL
			JR      OSCLI0
;
OSCLI2:			PUSH    DE
OSCLI3:			INC     DE
			INC     HL
			LD      A,(DE)
			CALL    UPPRC
			CP      '.'		; ABBREVIATED?
			JR      Z,OSCLI4
			XOR     (HL)
			JR      Z,OSCLI3
			CP      80H
			JR      Z,OSCLI4
			POP     DE
			JR      OSCLI1
;
OSCLI4:			POP     AF
		        INC     DE
OSCLI5:			BIT     7,(HL)
			INC     HL
			JR      Z,OSCLI5
			LD      A,(HL)
			INC     HL
			LD      H,(HL)
			LD      L,A
			PUSH    HL
			EX      DE,HL
			JP      SKIPSP

HUH:    		LD      A,254
        		CALL    EXTERR
        		DEFM    'Bad command'
        		DEFB    0

; ----------------------------------------------------------------------------

; OSCLI STAR commands

; Each command has bit 7 of the last character set, and is followed by the address of the handler
; It looks like these need to be in alphabetical order
;
COMDS:  		DC	'BYE':		DEFW STAR_BYE		; Soft reset
			DC	'CAT':		DEFW STAR_DOT		; Catalogue SD Card
			DC	'CD':		DEFW STAR_CD		; Change directory
			DC	'DELETE':	DEFW STAR_DELETE	; Delete a file
			DC	'DIR':		DEFW STAR_CD 		; Alias for CD
			DC	'DRIVE':	DEFW STAR_DRIVE		; Change drive
			DC	'ERASE':	DEFW STAR_DELETE	; Alias for DELETE
			DC	'FX':		DEFW STAR_FX		; FX commands
			DC	'LOAD':		DEFW STAR_LOAD		; Load memory block
			DC	'MEMDUMP': 	DEFW STAR_MEMDUMP	; Memory hex dump
			DC	'MKDIR':	DEFW STAR_MKDIR		; Make directory
			DC	'RMDIR':	DEFW STAR_RMDIR		; Remove directory
			DC	'SAVE':		DEFW STAR_SAVE		; Save memory block
			DC	'TEST': 	DEFW STAR_TEST		; Test code call for debugging new functions
			DC	'TIME': 	DEFW STAR_TIME		; RTC time
			DC	'TURBO':	DEFW STAR_TURBO		; CPU speed
			DB	0xFF

; OSCLI - BYE
;
STAR_BYE:		NEXTREG	0x02, 1		; Soft reset
			JR 	$		


; OSCLI - CAT / *.
;
STAR_DOT:		PUSH	IY
			LD	A, (FDRIVE)
			CALL	NEXT_DOS.LS
			POP	IY
			RET 

; OSCLI - CD path
;
STAR_CD:		LD	DE, NEXT_DOS.CD
STAR_CD_1:		CALL	SKIPSP
			PUSH	HL
			CALL	CRTONULL
			EXREG 	HL, IX
			LD	A, (FDRIVE)
			EX	DE, HL
			CALLREG	HL
			POP	HL
			JP	NULLTOCR

; OSCLI - DELETE path
;
STAR_DELETE:		LD	DE, NEXT_DOS.Delete
			JR	STAR_CD_1

; OSCLI - MKDIR path
;
STAR_MKDIR:		LD	DE, NEXT_DOS.MKDIR
			JR	STAR_CD_1

; OSCLI - RMDIR path
;
STAR_RMDIR:		LD	DE, NEXT_DOS.RMDIR
			JR	STAR_CD_1

; OSCLI - DRIVE d 
;
STAR_DRIVE:		CALL	SKIPSP
			LD	A, (HL)
			CP	CR
			RET	Z
			JP	NEXT_DOS.DRIVE

; OSCLI FX n
; 19: HSYNC
;
STAR_FX:		CALL	ASC_TO_NUMBER
			LD	A, E
			CP	19
			JR	Z, STAR_FX_19 
			JP 	HUH
STAR_FX_19:		HALT
			RET

; OSCLI MEMDUMP addr, count
; 
STAR_MEMDUMP		CALL	ASC_TO_NUMBER	; Get start address
			PUSH	DE 
			CALL	SKIPSP 
			CALL	ASC_TO_NUMBER	; Get length in DE
			POP	HL 		; Get start address in HL
			JP	NEXT_DEBUG.Memory_Dump

; OSCLI TEST
; Stick code to test here
;
STAR_TEST:		CALL	ASC_TO_NUMBER
			PUSH	DE
			CALL	SKIPSP 
			CALL	ASC_TO_NUMBER
			PUSH	DE 
			CALL	SKIPSP	
			CALL	ASC_TO_NUMBER
			POP	BC
			POP	HL
			CALL	NEXT_GRAPHICS.Primitive_Line_Horz
			RET
;
			LD	DE, 960
			LD	HL, 512
			CALL	NEXT_GRAPHICS.Transform_Coords
			RET 
;
			CALL	ASC_TO_NUMBER	
			LD	A, E		 
			PUSH	AF		; Sprite #
			CALL	SKIPSP 
			CALL	ASC_TO_NUMBER
			PUSH	DE 		; X
			CALL	SKIPSP 
			CALL	ASC_TO_NUMBER
			PUSH	DE		; Y
			CALL	SKIPSP	
			CALL	ASC_TO_NUMBER
			LD	C, E 		; Pattern #
			POP	HL 		; Y 
			POP	DE 		; X
			POP	AF		; Sprite #
			JP	NEXT_SPRITES.Render

; OSCLI TIME
; Output current time
;
STAR_TIME:		CALL	GETIMS
			EX	DE, HL 
			LD	(HL), LF
			INC	HL 
			LD	(HL), CR
			INC	HL
			LD	(HL), 0
			LD	HL, ACCS
			JP	MAIN.TEXT 	

; OSCLI TURBO n
; Set CPU Speed: 0 = 3.5Mhz, 1 = 7Mhz, 2 = 14Mhz, 3 = 28Mhz
;
STAR_TURBO:		CALL	ASC_TO_NUMBER
			LD	A, E 
			AND 	3
			LD	(CPU_SPEED), A
			NEXTREG	0x07, A 
			RET

; OSCLI LOAD file addr
;
STAR_LOAD:		CALL	SKIPSP		; First parameter is a string
			PUSH	HL		; Stack the string pointer
			CALL	SKIPNOTSP	; Skip to the next parameter
			CALL	ASC_TO_NUMBER	; DE: Address
			POP	HL		; HL: Pointer to Filename
			CALL	SPTONULL	; Convert to null terminated string
			PUSH	HL
			EXREG	HL, IX
			LD	BC, -1		; Maximum number of bytes
			LD	A, (FDRIVE)
			CALL	NEXT_DOS.Load
			POP	HL 
			RET

; OSCLI	SAVE file addr len
;
STAR_SAVE:		CALL	SKIPSP		; First parameter is a string
			PUSH	HL		; Stack the string pointer
			CALL	SKIPNOTSP	; Skip to the next parameter
			CALL	ASC_TO_NUMBER	; Read address
			PUSH	DE 
			CALL	ASC_TO_NUMBER	; Read length
			EXREG	DE, BC		; BC: Length
			POP	DE 		; DE: Start address
			POP	HL		; HL: Pointer to Filename
			CALL	SPTONULL	; Convert to null terminated string
			PUSH	HL
			EXREG	HL, IX
			LD	A, (FDRIVE)
			CALL	NEXT_DOS.Save
			POP	HL
			RET

; ----------------------------------------------------------------------------

; PUT port,data[,type]
; Moved from exec.z80
;
@PUT:			CALL    EXPRI           ; PORT ADDRESS
			EXX
			PUSH    HL
			CALL    COMMA
			CALL    EXPRI           ; DATA
			EXX
			PUSH	HL
			CALL    NXT		; If no third parameter passed
			CP	","		; Can we find a comma
			LD	A, 0		; Default value
			JR 	NZ, 1F		; No, so skip third parameter
			CALL	COMMA		; Yes, so skip the comma
			CALL	EXPRI		; TYPE
			EXX
			LD	A, L		;  A = TYPE
1:			POP	HL		;  L = DATA
			POP	BC		; BC = PORT/REGISTER
			OR	A 
			JR	Z, 2F	
			DEC	A 
			JR	Z, 3F
			JP	XEQ		; TODO: Error here
2:			OUT     (C), L          ; OUTPUT TO PORT BC
			JP      XEQ
3:			Z80PORT	0x243B, C	; Nextreg port
			INC	B
			OUT	(C), L
			JP	XEQ

; GET(port[,type])
; Called from GET in eval.z80
;
@GET_PORT:		INC	IY		; Skip '('
			CALL    EXPRI           ; PORT ADDRESS
			EXX
			PUSH	HL
			CALL	NXT
			CP	","
			LD	A, 0		; Default type
			JR	NZ, 1F
			CALL	COMMA		; Skip comma
			CALL	EXPRI		; Type
			EXX
			LD	A, L		;  A = TYPE
1:			POP	BC		; BC = PORT/REGISTER
			OR	A 
			JR	Z, 2F 		; If zero, skip to plain Z80 fetch
			Z80PORT	0x243B, C	; Nextreg port
			INC	B
2:			IN	L,(C)		; Read value
			CALL    BRAKET
			JP      EVAL.COUNT0

; ----------------------------------------------------------------------------

; COLOUR col[,type]
; Set the text colour
;   col: 0-127 (foreground), 128-255 (backround)
;  type: 0: BBC spec (default)
;        1: foreground / ULA ink
;        2: background / ULA paper
;        3: border
;        4: ULA bright
;        5: ULA flash
;
@COLOUR:		CALL    EXPRI
			EXX
			PUSH	HL
			CALL	NXT 
			CP	","
			LD	L, 0		; Default type
			JR	NZ,1F
			CALL	COMMA		; Skip comma
			CALL	EXPRI		; Type
			EXX
1:			POP	BC		;  C: Colour
			LD	B, L		;  B: Type
			CALL	NEXT_GRAPHICS.Set_Text_Colour
			JP	XEQ 

; GCOL mode,colour[,type]
; As COLOUR
;
@GCOL:			CALL	EXPR_P2		; DE: mode, HL: colour
			LD	A, E 
			LD	(PLOT_MODE), A 
			PUSH	HL		; Stack the colour
			CALL	NXT 		; Is there a type parameter?
			CP	","
			LD	L, 0		; Default type
			JR	NZ,1F
			CALL	COMMA		; Skip comma
			CALL	EXPRI		; Type
			EXX
1:			POP	BC		;  C: Colour
			LD	B, L		;  B: Type
			CALL	NEXT_GRAPHICS.Set_Plot_Colour
			JP	XEQ 

; PLOT mode,x,y
;
@PLOT:			CALL	EXPRI		; Get the plot type (line, plot, etc)
			EXX
			PUSH	HL	
			CALL	COMMA 
			CALL	EXPR_P2		; DE: X, HL: Y
			CALL	NEXT_GRAPHICS.Transform_Coords
			POP	BC		; Plot type in C
			LD	A, C 		; Plot type in A
			PUSH	HL		; Y
			PUSH	DE		; X
			CALL	NEXT_GRAPHICS.Plot
@PLOT_1:		POP	DE 		
			POP	HL	
			CALL	MOVE_1
1:			JP	XEQ

; MOVE x, y
;
@MOVE:			CALL	EXPR_P2		; DE: X, HL: Y
			CALL	NEXT_GRAPHICS.Transform_Coords
			CALL	MOVE_1
			JP	XEQ
;
@MOVE_1:		LD	BC, (PLOTPOS_X)	; Store the previous plot points
			LD 	(PLOTPRE_X), BC 
			LD	BC, (PLOTPOS_Y)
			LD	(PLOTPRE_Y), BC
			LD	(PLOTPOS_X), DE	; And store the latest plot point
			LD	(PLOTPOS_Y), HL 
			RET

; DRAW x, y
;
@DRAW:			CALL	EXPR_P2		; DE: X, HL: Y
			CALL	NEXT_GRAPHICS.Transform_Coords
			CALL	NXT 		; Are there any more paramters?
			CP	","		
			JR	NZ, 1F		; No, so just do 'DRAW x, y'
			CALL	COMMA		; Okay, we're now doing 'DRAW x1,y1,x2,y2
			CALL	MOVE_1		; MOVE x1,y1 (DE, HL)
			CALL	EXPR_P2		; DE: X2, HL: Y2
			CALL	NEXT_GRAPHICS.Transform_Coords
1:			PUSH	HL 		; Stack X2
			PUSH	DE		; Stack Y2
			CALL	NEXT_GRAPHICS.Plot_Line
			JR	PLOT_1	

; POINT(x,y)
;
@POINT:			CALL	EXPR_P2		; DE: X, HL: Y
			CALL	NEXT_GRAPHICS.Transform_Coords
			CALL	NEXT_GRAPHICS.Point
			LD	L, A
1:			CALL	BRAKET
			JP      EVAL.COUNT0

; Get two values from EXPR in DE, HL
; IY: Pointer to expression string
; Returns:
; DE: P1
; HL: P2
;
@EXPR_P2:		CALL	EXPRI		; Get first parameter	
			EXX
			PUSH	HL
			CALL	COMMA 
			CALL	EXPRI		; Get second parameter
			EXX
			POP	DE
			RET

; ----------------------------------------------------------------------------

;OSLOAD - Load an area of memory from a file.
;   Inputs: HL addresses filename (CR terminated)
;           DE = address at which to load
;           BC = maximum allowed size (bytes)
;  Outputs: Carry reset indicates no room for file.
; Destroys: A,B,C,D,E,H,L,F
;
@OSLOAD:		CALL	CRTONULL
			PUSH	HL 
			POP	IX 
			LD	A, (FDRIVE)
			JP	NEXT_DOS.Load

;OSSAVE - Save an area of memory to a file.
;   Inputs: HL addresses filename (term CR)
;           DE = start address of data to save
;           BC = length of data to save (bytes)
; Destroys: A,B,C,D,E,H,L,F
;
@OSSAVE:		CALL	CRTONULL
			PUSH	HL 
			POP	IX 
			LD	A, (FDRIVE)
			JP	NEXT_DOS.Save

; ----------------------------------------------------------------------------

; SOUND channel,volume,pitch,duration
; volume: 0 (off) to -15 (full volume)
; pitch: 0 - 255
; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
;
@SOUND:			CALL	EXPR_P2		; DE: Channel/Control, HL: Volume
			LD	A, L 		;  A: Volume
			PUSH	AF 
			PUSH	DE
			CALL	COMMA
			CALL	EXPR_P2		; DE: Pitch, HL: Duration
			LD	D, E		;  D: Pitch
			LD	E, L 		;  E: Duration
			POP	HL 		; HL: Channel/Control
			POP	AF
			NEG
			LD	C, A 		;  C: Volume
			CALL	NEXT_SOUND.Queue_Note
			JP	XEQ

; ----------------------------------------------------------------------------

; Stuff not implemented yet
; There's also more stuff in sorry.z80
;
@OSBPUT:
@OSBGET:
@OSSTAT:
@OSSHUT:
@OSOPEN:
@OSCALL:
@GETPTR:
@PUTPTR:
@GETEXT:
@RESET:
			RET

			ENDMODULE