;
; Title:	BBC Basic Interpreter - Z80 version
;		Patch file for Spectrum Next
; Author:	Dean Belfield
; Created:	02/05/2021
; Last Updated:	15/05/2021
;
; Modinfo:
; 09/05/2021:	Fixed plot mode and bug in COMDS table
; 10/05/2021:	Added RTC TIME$ and *TIME, moved some code into misc.z80, and changes due to VDU support
; 15/05/2021:	References to ASC_TO_HEX changed to ASC_TO_NUMBER in STAR commands; Updates for MODE command

			MODULE PATCH

; MODE n: Set video mode
;
@MODE:			CALL    EXPRI
			EXX
			LD	A, L
			CALL	NEXT_GRAPHICS.Set_Video_Mode
			JP	XEQ

; CLG: clear the graphics screen
;
@CLG:			LD	A, 0x10
			CALL	OSWRCH 
			JP	XEQ

; CLRSCN: clears the screen.
;
@CLRSCN:		LD	A, 0x0C
			JP	OSWRCH

; PUTIME: set current time to DE:HL, in centiseconds.
;
@PUTIME:		LD	(TIME + 2), DE
			LD	(TIME + 0), HL
			RET

; GETIME: return current time in DE:HL, in centiseconds.
;
@GETIME:		LD	DE, (TIME + 2)
 	  		LD	HL, (TIME + 0)
			RET

; Get the time string from the real-time clock module
;
@GETIMS:		JP	NEXT_RTC.GET_DATE_STRING

; PUTCSR: move to cursor to x=DE, y=HL
;
@PUTCSR:		PUSH	AF 
			LD	A, E
			LD	(CHARPOS_X), A 
			LD	A, D 
			LD	(CHARPOS_Y), A 
			POP	AF
			RET

; GETCSR: return cursor position in x=DE, y=HL
;
@GETCSR:		PUSH	AF
			LD	D, 0
			LD	H, 0 
			LD	A,(CHARPOS_X)
			LD	E, A
			LD 	A,(CHARPOS_Y)
			LD	L, A
			POP	AF
			RET

; OSRDCH: read a character in from the keyboard (non-blocking)
;
@OSRDCH:		LD	A, (KEYCODE)			; Wait for key to be released
			AND	A 
			JR	NZ, @OSRDCH
1:			LD	A, (KEYCODE)			; And pressed again
			AND	A 
			JR	Z, 1B
			RET

; PROMPT: output the input prompt
;
@PROMPT: 		LD	A,'>'

; OSWRCH: write a character out
;
@OSWRCH:		JP	NEXT_IO.Print_Char

;OSKEY - Read key with time-limit, test for ESCape.
;Main function is carried out in user patch.
;   Inputs: HL = time limit (centiseconds)
;  Outputs: Carry reset if time-out
;           If carry set A = character
; Destroys: A,H,L,F
;
@OSKEY:			DEC	HL 
			LD	A,H
			OR	L
			RET	Z 
			CALL	OSRDCH
			OR	A
			JR	Z,OSKEY
			CP	0x1B		; ESC
			SCF 
			RET	NZ
ESCSET: 		PUSH    HL
        		LD      HL,FLAGS
        		BIT     6,(HL)          ; ESC DISABLED?
        		JR      NZ,ESCDIS
        		SET     7,(HL)          ; SET ESCAPE FLAG
ESCDIS: 		POP     HL
        		RET	
ESCTEST:		LD	A, (KEYCODE)
			CP	0x1B		; ESC	
			JR	Z,ESCSET
			RET

@TRAP:			CALL	ESCTEST
@LTRAP:			LD	A,(FLAGS)
			OR	A
			RET	P
			LD	HL,FLAGS 
			RES	7,(HL)
			JP	ESCAPE

;OSINIT - Initialise RAM mapping etc.
;If BASIC is entered by BBCBASIC FILENAME then file
;FILENAME.BBC is automatically CHAINed.
;   Outputs: DE = initial value of HIMEM (top of RAM)
;            HL = initial value of PAGE (user program)
;            Z-flag reset indicates AUTO-RUN.
;  Destroys: A,D,E,H,L,F
;
@OSINIT: 		XOR	A
			LD	(@FLAGS), A		; Clear flags
         		LD 	DE, Stack_Top		; DE = HIMEM
         		LD 	E, A			; PAGE BOUNDARY
         		LD 	HL, @USER
         		RET	

;OSLINE - Read/edit a complete line, terminated by CR.
;   Inputs: HL addresses destination buffer.
;           (L=0)
;  Outputs: Buffer filled, terminated by CR.
;           A=0.
; Destroys: A,B,C,D,E,H,L,F
;
@OSLINE:		CALL	OSRDCH
			OR	A 
			JR	Z,OSLINE
			CP	0x0D		; CR
			JR	Z,KEYCR		
			CP	0x7F		; Backspace
			JR	Z,KEYBS
			LD	(HL),A		; Save the character in the buffer
			INC	HL
			CALL	OSWRCH		; Echo character back to terminal
			JR	OSLINE		; Loop

KEYCR:			LD	(HL),A		; Write final CR
			CALL	@CRLF		; Print CR
			AND	A
			RET 

KEYBS:			INC	L		; Check for beginning of line
			DEC	L 
			JR	Z,OSLINE
			CALL	OSWRCH
			DEC	L
			JR	OSLINE

;OSCLI - Process an "operating system" command
;
@OSCLI: 		CALL    SKIPSP
			CP      CR
			RET     Z
			CP      '|'
			RET     Z
			CP      '.'
			JP      Z,STAR_DOT	; *.
			EX      DE,HL
			LD      HL,COMDS
OSCLI0:			LD      A,(DE)
			CALL    UPPRC
			CP      (HL)
			JR      Z,OSCLI2
			JR      C,HUH
OSCLI1:			BIT     7,(HL)
			INC     HL
			JR      Z,OSCLI1
			INC     HL
			INC     HL
			JR      OSCLI0
;
OSCLI2:			PUSH    DE
OSCLI3:			INC     DE
			INC     HL
			LD      A,(DE)
			CALL    UPPRC
			CP      '.'		; ABBREVIATED?
			JR      Z,OSCLI4
			XOR     (HL)
			JR      Z,OSCLI3
			CP      80H
			JR      Z,OSCLI4
			POP     DE
			JR      OSCLI1
;
OSCLI4:			POP     AF
		        INC     DE
OSCLI5:			BIT     7,(HL)
			INC     HL
			JR      Z,OSCLI5
			LD      A,(HL)
			INC     HL
			LD      H,(HL)
			LD      L,A
			PUSH    HL
			EX      DE,HL
			JP      SKIPSP

HUH:    		LD      A,254
        		CALL    EXTERR
        		DEFM    'Bad command'
        		DEFB    0

; ----------------------------------------------------------------------------

; OSCLI STAR commands

; Each command has bit 7 of the last character set, and is followed by the address of the handler
; It looks like these need to be in alphabetical order
;
COMDS:  		DC	'CAT':		DEFW STAR_DOT		; Catalogue SD Card
			DC	'FX':		DEFW STAR_FX		; FX commands
			DC	'MEMDUMP': 	DEFW STAR_MEMDUMP	; Memory hex dump
			DC	'TEST': 	DEFW STAR_TEST		; Test code call for debugging new functions
			DC	'TIME': 	DEFW STAR_TIME
			DC	'TURBO':	DEFW STAR_TURBO		; CPU speed
			DB	0xFF

; OSCLI - *CAT / *.
;
STAR_DOT:		RET 

; OSCLI TURBO n
; Set CPU Speed: 0 = 3.5Mhz, 1 = 7Mhz, 2 = 14Mhz, 3 = 28Mhz
;
STAR_TURBO:		CALL	ASC_TO_NUMBER
			LD	A, E 
			NEXTREG	0x07, A 
			RET

; OSCLI FX n
; 19: HSYNC
;
STAR_FX:		CALL	ASC_TO_NUMBER
			LD	A, E
			CP	19
			JR	Z, STAR_FX_19 
			JP 	HUH
STAR_FX_19:		HALT
			RET

; OSCLI MEMDUMP addr, count
; 
STAR_MEMDUMP		CALL	ASC_TO_NUMBER	; Get start address
			INC	HL
			PUSH	DE 
			CALL	ASC_TO_NUMBER	; Get length in DE
			POP	HL 		; Get start address in HL
			JP	NEXT_DEBUG.Memory_Dump

; OSCLI TEST
; Stick code to test code here
;
STAR_TEST:		RET

; OSCLI TIME
; Output current time
;
STAR_TIME:		CALL	GETIMS
			EX	DE, HL 
			LD	(HL), 0x0A
			INC	HL 
			LD	(HL), 0x0D
			INC	HL
			LD	(HL), 0
			LD	HL, ACCS
			JP	MAIN.TEXT 	

; ----------------------------------------------------------------------------

; PUT port,data[,type]
; Moved from exec.z80
;
@PUT:			CALL    EXPRI           ; PORT ADDRESS
			EXX
			PUSH    HL
			CALL    COMMA
			CALL    EXPRI           ; DATA
			EXX
			PUSH	HL
			CALL    NXT		; If no third parameter passed
			CP	','		; Can we find a comma
			LD	A, 0		; Default value
			JR 	NZ, 1F		; No, so skip third parameter
			INC	IY		; Yes, so skip the comma
			CALL	EXPRI		; TYPE
			EXX
			LD	A,L		;  A = TYPE
1:			POP	HL		;  L = DATA
			POP	BC		; BC = PORT/REGISTER
			OR	A 
			JR	Z, 2F	
			DEC	A 
			JR	Z, 3F
			JP	XEQ		; TODO: Error here
2:			OUT     (C),L           ; OUTPUT TO PORT BC
			JP      XEQ
3:			LD	A,C		; Get register value TODO: Error if B is not zero
			LD	BC,0x243B	; Set Next register number
			OUT	(C),A 
			INC	B
			OUT	(C),L
			JP	XEQ

; GET(port[,type])
; Called from GET in eval.z80
;
@GET_PORT:		INC	IY		; Skip '('
			CALL    EXPRI           ; PORT ADDRESS
			EXX
			PUSH	HL
			CALL	NXT
			CP	','
			LD	A, 0		; Default type
			JR	NZ,1F
			INC	IY		; Skip comma
			CALL	EXPRI		; Type
			EXX
			LD	A, L		;  A = TYPE
1:			POP	BC		; BC = PORT/REGISTER
			OR	A 
			JR	Z, 2F 		; If zero, skip to plain Z80 fetch
			LD 	A,C		; Get register value in A
			LD	BC,0x243B	; Nextreg port
			OUT	(C),A		; Select register from Next to read
			INC	B
2:			IN	L,(C)		; Read value
			CALL    BRAKET
			JP      EVAL.COUNT0

; COLOUR 0-7 (Ink)
; COLOUR 128-135 (Paper)
;
@COLOUR:		CALL    EXPRI
			EXX
			LD	A, L 
			LD	HL, TEXT_COLOUR
			CALL	NEXT_GRAPHICS.Set_Colour
			JP	XEQ
; GCOL mode, colour
;
@GCOL:			CALL	EXPRI		; Get the mode
			EXX
			LD	A, L
			LD	(PLOT_MODE), A 
			CALL	COMMA
			CALL	EXPRI		; Get the colour
			EXX 
			LD	A, L
			LD	HL, PLOT_COLOUR
			CALL	NEXT_GRAPHICS.Set_Colour
			JP	XEQ 

; PLOT mode,x,y
;
@PLOT:			CALL	EXPRI		; Get the plot type (line, plot, etc)
			EXX
			PUSH	HL		
			CALL	COMMA 
			CALL	MOVE_1		; Get X and Y parameters
			POP	HL		; Plot type in L
			LD	A, L 		; Plot type in A
			LD	DE, (PLOTPOS_X)
			LD	HL, (PLOTPOS_Y)
			CALL	NEXT_GRAPHICS.Plot
1:			JP	XEQ

; MOVE x, y
;
@MOVE:			CALL	MOVE_1		; Get X and Y parameters
			JP	XEQ
@MOVE_1:		LD	HL, (PLOTPOS_X)	; Store the previous plot points
			LD 	(PLOTPRE_X), HL 
			LD	HL, (PLOTPOS_Y)
			LD	(PLOTPRE_Y), HL
			CALL	EXPRI		; Get X
			EXX 
			LD	(PLOTPOS_X), HL	; And store
			CALL	COMMA 
			CALL	EXPRI		; Get Y
			EXX 
			LD	(PLOTPOS_Y), HL ; And store
			RET 

; DRAW x, y
;
@DRAW:			CALL	EXPRI		; Get X2
			EXX 
			PUSH 	HL		; Stack it
			CALL	COMMA 
			CALL	EXPRI		; Get Y2
			EXX
			LD	A, L 		; A: Y2
			POP	HL 		; L: X2
			LD	H, A		; H: Y2
			PUSH	HL 		; Stack that coordinate pair

			CALL    NXT		; If no third parameter passed
			CP	','		; Can we find a comma
			JR 	Z, 1F		; Yes, so fetch two more parameters

			LD	A, (PLOTPOS_X)	; No, so get defaults from PLOTPOS
			LD	L, A 		; L: X1
			LD	A, (PLOTPOS_Y)
			LD	H, A 		; H: Y1 
			PUSH	HL		; Stackit
			JR	2F		; Jump to plot

1:			INC	IY		; Skip the comma
			CALL	EXPRI		; Get Y1
			EXX 
			PUSH 	HL		; Stack it
			CALL	COMMA 
			CALL	EXPRI		; Get Y1
			EXX
			LD	A, L 		; A: Y1
			POP	HL 		; L: X1
			LD	H, A		; H: Y1
			PUSH	HL 		; Stack that coordinate pair

2:			POP	DE 		; Pop (X1,Y1)
			POP	HL		; Pop (X2,Y2)
			CALL	NEXT_GRAPHICS.Draw_Line
			JP	XEQ 

; POINT(x,y)
;
@POINT:			CALL	EXPRI		; Get X coordinate	
			EXX
			PUSH	HL
			CALL	COMMA 
			CALL	EXPRI		; Get Y coordinate
			EXX
			POP	DE		; HL = Y, DE = X
			LD	D, L		; D = Y, E = X
			PIXELAD			; Get the pixel address in HL
			SETAE			; Get pixel position in A
			AND	(HL)		; Mask out pixel
			LD	L, 0
			JR	Z, 1F
			INC	L
1:			CALL	BRAKET
			JP      EVAL.COUNT0

; Stuff not implemented yet
; There's also more stuff in sorry.z80
;
@OSBPUT:
@OSBGET:
@OSSTAT:
@OSSHUT:
@OSOPEN:
@OSCALL:
@OSSAVE:
@OSLOAD:
@GETPTR:
@PUTPTR:
@GETEXT:
@RESET:
			RET

			ENDMODULE