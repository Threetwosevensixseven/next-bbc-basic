;
; Title:	BBC Basic Interpreter - Z80 version
;		Spectrum Next Layer 2 Graphics Routines
; Author:	Dean Belfield
; Created:	13/05/2021
; Last Updated:	04/06/2021
;
; TODO:		L2 will read read/write access to the screen for any plot operation other than SET
;
; Modinfo:
; 14/05/2021:	Added plot modes
; 15/05/2021:	Plot now pulls PLOT_MODE and PLOT_COLOUR direct from RAM; Updates for MODE command
; 17/05/2021:	Tweaks for COLOUR, GCOL
; 20/05/2021:	Added Draw_Horz_Line
; 22/05/2021:	Added Point
; 24/05/2021:	Clear_Line now uses the background colour
; 26/05/2021:	Added support code for Layer 2 modes 2 and 3
; 04/06/2021:	Point and Triangle now work correctly with scroll offset

			MODULE	NEXT_GRAPHICS_L2

; Set the video modes up
;
Set_Video_Mode_M1:	LD	A, %00000000		; 256 x 192 x 8
			LD	E, %00100011		; Sprites & clipping, SLU priority
			LD	C, 32 
			LD	B, 24 
			LD	D, 191
			JR	Set_Video_Mode
;
Set_Video_Mode_M2:	LD	A, %00010000		; 320 x 256 x 8
			LD	E, %00100011		; Sprites & clipping, SLU priority
			LD	C, 40
			LD	B, 32
			LD	D, 255
			JR	Set_Video_Mode
;
Set_Video_Mode_M3:	LD	A, %00010000		; 640 x 256 x 4
			LD	E, %00100011		; Sprites, no clipping, SLU priority
			LD	C, 40
			LD	B, 32
			LD	D, 255
;
Set_Video_Mode:		PUSH	AF, BC, DE
			XOR	A
			LD	(TEXT_BACKGROUND), A
			DEC	A
			LD	(TEXT_FOREGROUND), A 
			LD	(PLOT_COLOUR), A
			LD	(CHAR_COLS), BC
			LD	H, 0
			LD	L, C 
			ADD	HL, HL 
			ADD	HL, HL 
			ADD	HL, HL
			LD	(PIXEL_WIDTH), HL 
			LD	H, 0
			LD	L, B
			ADD	HL, HL 
			ADD	HL, HL 
			ADD	HL, HL
			LD	(PIXEL_HEIGHT), HL
			CALL	NEXT_GRAPHICS.Clear_Screen
			POP	DE, BC, AF
			NEXTREG 0x70, A
			LD	A, E
			NEXTREG 0x15, A		
			LD	A, D			; Set clipping
			NEXTREG	0x18, 0		
			NEXTREG	0x18, 255
			NEXTREG	0x18, 0
			NEXTREG	0x18, A
			RET


; Clear the screen
;
Clear_Screen_M1:	LD	B, 3 
			JR	Clear_Screen 
;
Clear_Screen_M2:
Clear_Screen_M3:	LD	B, 5
;
Clear_Screen:		LD	A, (BORDER_COLOUR)
			OUT 	(254), A
			NEXTREG	0x17, 0			; Scroll register
			Z80PORT	0x123B, %00000011	; Enable for memory writes
1:			PUSH	BC
			LD	A, B 
			DEC	A 
			OR	%00010000		; Set to page relative to current page
			Z80PRTA	0x123B
			LD	A, (TEXT_BACKGROUND)
			LD	DE,0x0000
			LD	BC,0x4000
			CALL	NEXT_DMA.FillDMA
			POP	BC
			DJNZ	1B
			Z80PORT	0x123B, %00000010	; Disable memory writes
			RET

; Scroll
;  H: Line to clear after scroll
;
Set_Scroll_Reg:		LD	A, (SCRLPOS_Y)
			ADD	A, A
			ADD	A, A
			ADD	A, A 
			NEXTREG	0x17, A
			RET 

; Adjust HL for scroll position
; HL: Y
; Returns:
; HL: Y adjusted for Y 
;
Adjust_SCRLPOS_P:	LD	A, (SCRLPOS_Y)		; Get Y scroll position
			ADD	A, A
			ADD	A, A 
			ADD	A, A 			; Multiply by 8
			ADD	A, L 			; Add to pixel Y position
			LD	L, A			; Wraps 
			RET

; Print a single character out to an X/Y position
;  E: Character to print
;  L: X Coordinate
;  H: Y Coordinate
;
Print_Char_M3:		CALL	Get_Char_Address_M3
			LD 	D, 8			; Multiply the character byte by 8
			MUL 	D,E
			LD 	A,0x3C			; Address of character set in ROM (HIGH)
			ADD 	A,D
			LD 	D,A
			LD	BC, (TEXT_FOREGROUND)	; C: Foreground, B: Background
			LD	A, (DE)			; Get the byte from ROM into A
;
			LD	D, 4 			; Inner loop counter
1:			PUSH	DE 
			LD	E, A 			
			SLA	E			; Get first nibble
			JR	C, 3F 
			LD	D, B 
			JR	4F
3:			LD	D, C 
4:			SLA	E			; Get second nibble
			JR	C, 5F 
			LD	A, B 
			JR	6F
5:			LD	A, C
6:			SWAPNIB			
			OR	D
			SWAPNIB
			LD	(HL), A
			POP	DE
			DEC	D 
			JR	NZ, 1B
			RET
;
Print_Char_M2:		CALL	Get_Char_Address_M2
			LD 	D, 8			; Multiply the character byte by 8
			MUL 	D, E
			LD 	A, 0x3C			; Address of character set in ROM (HIGH)
			ADD 	A, D
			LD 	D, A
			LD	BC, (TEXT_FOREGROUND)	; C: Foreground, B: Background
			LD	IXH, 8			; Outer Loop counter
1:			PUSH	HL
			LD	A, (DE)			; Get the byte from the ROM into A
			LD	IXL, 8			; Inner loop counter
2:			ADD	A, A
			JR	C, 3F
			LD	(HL), B			; Set background colour
			JR	4F
3:			LD	(HL), C			; Set foreground colour
4:			INC	H
			DEC	IXL
			JR	NZ, 2B
			INC 	DE			; Goto next byte of character
			POP	HL
			INC	L			; Goto next line on screen
			DEC	IXH
			JR 	NZ, 1B			; Loop around whilst it is Not Zero (NZ)
			Z80PORT	0x123B, %00000010	; Disable memory writes
			RET
;
Print_Char_M1:		CALL 	Get_Char_Address_M1
			LD 	D, 8			; Multiply the character byte by 8
			MUL 	D,E
			LD 	A,0x3C			; Address of character set in ROM (HIGH)
			ADD 	A,D
			LD 	D,A
			LD	BC, (TEXT_FOREGROUND)	; C: Foreground, B: Background
			LD	IXH,8			; Outer Loop counter
1:			PUSH	HL
			LD	A,(DE)			; Get the byte from the ROM into A
			LD	IXL, 8			; Inner loop counter
2:			ADD	A, A
			JR	C, 3F
			LD	(HL),B			; Set background colour
			JR	4F
3:			LD	(HL),C			; Set foreground colour
4:			INC	L
			DEC	IXL
			JR	NZ, 2B
			INC 	DE			; Goto next byte of character
			POP	HL
			INC	H			; Goto next line on screen
			DEC	IXH
			JR 	NZ,1B			; Loop around whilst it is Not Zero (NZ)
			Z80PORT	0x123B, %00000010	; Disable memory writes
			RET

; Gets the ASCII code of a chararcter on-screen
;  L: X Coordinate
;  H: Y Coordinate
; Returns ASCII in A
;
Get_Char:		RET

; Get screen address
;  H = Y character position
;  L = X character position
;  Returns address in HL
;
Get_Char_Address_M1:	SLA	L 			; Multiply X by 8
			SLA	L 
			SLA	L
			LD	A, H 			; Multiply Y by 8		
			RLCA 
			RLCA 
			RLCA 
			LD	H, A			; Get the Y coordinate
			AND	0xC0			; Get the bank number
			RLCA 
			RLCA 
			OR	%00010000
			Z80PRTA	0x123B
			Z80PORT	0x123B, %00000011
			LD	A, H
			AND	0x3F 
			LD	H, A
			RET
;
Get_Char_Address_M3:	SRL	L 			; Divide X by 2
Get_Char_Address_M2:	LD	A, L 			; X	
			AND	%00111000		; Get the bank number
			RRCA 
			RRCA 
			RRCA 
			OR	%00010000
			Z80PRTA	0x123B
			Z80PORT	0x123B, %00000011
			LD	A, L 			; Swap X and Y
			LD	L, H
			SLA	L			; Multiply Y by 8
			SLA	L
			SLA	L
			ADD	A, A 			; Multiply X by 8
			ADD	A, A
			ADD	A, A 
			AND	0x3F
			LD	H, A
			RET

; Get pixel position
; Pages in the correct 16K Layer 2 screen bank into 0x0000
; DE: X
; HL: Y
; Returns:
; HL: Address in memory (between 0x0000 and 0x3FFF)
;
Get_Pixel_Address_M1:	LD	D, L 			; Store the Y coordinate in D
			LD 	L, E			; The low byte is the X coordinate
			LD	A, D			; Get the Y coordinate
			AND	0x3F			; Offset in bank
			LD	H, A			; Store in high byte
			LD	A, D			; Get the Y coordinate
			AND	0xC0			; Get the bank number
			RLCA 
			RLCA 
			OR	%00010000
			Z80PRTA	0x123B
			Z80PORT	0x123B, %00000011
			RET
;
Get_Pixel_Address_M2:	LD	A, E			; Get the X coordinate
			AND	0x3F			; Offset in bank
			LD	H, A			; Store in high byte
			LD	B, 6 
			BSRA 	DE, B 			
			LD	A, E			; Get the X coordinate
			OR	%00010000
			LD	E, A
			Z80PRTA	0x123B
			Z80PORT	0x123B, %00000011
			RET

; Read a point
; HL: X
; DE: Y	
;	
Point_M1:		CALL	Get_Pixel_Address_M1: LD A, (HL): RET
Point_M2:		CALL	Get_Pixel_Address_M1: LD A, (HL): RET
Point_M3:		RET

; Plot a point
; HL: Y
; DE: X
;	
;
Plot_M3:		RET
;
Plot_M2:		CALL	Adjust_SCRLPOS_P
			CALL	Get_Pixel_Address_M2
			JR	Plot
;
Plot_M1:		CALL	NEXT_GRAPHICS.NEXT_GRAPHICS_ULA.Adjust_SCRLPOS_P
			CALL	Get_Pixel_Address_M1
Plot:			LD	A, (PLOT_MODE)		; Check plot mode is valid
			CP	7
			RET	NC			; Do nothing if plot mode >=7
			LD	A, (PLOT_COLOUR)
			LD	E, A
			LD	A, (PLOT_MODE)
			CALL	SWITCH_A
Plot_Table:		DEFW	Plot_SET
			DEFW	Plot_OR
			DEFW	Plot_AND
			DEFW	Plot_XOR
			DEFW	Plot_NOT
			DEFW	Plot_NOP
			DEFW	Plot_CLR

Plot_CLR:		LD	(HL), 0
Plot_NOP:		RET
Plot_SET:		LD	(HL), E
			RET
Plot_AND:		LD	A, (HL)
			AND	E
			LD	(HL), A
			RET 
Plot_OR:		LD	A, (HL)
			OR	E
			LD	(HL), A 
			RET
Plot_XOR:		LD	A, (HL)
			XOR	E
			LD	(HL), A 
			RET 
Plot_NOT:		LD	A, (HL)
			CPL
			LD	(HL), A 
			RET 

; Draw Horizontal Line routine
; HL: Y coordinate
; BC: X pixel position 1
; DE: X pixel position 2
;
Draw_Horz_Line_M1:	CALL	NEXT_GRAPHICS.NEXT_GRAPHICS_ULA.Adjust_SCRLPOS_P
;
			LD	B, C 			; B: Low X1, E: Low X2
			LD	D, L 			; D: Low Y
;
			LD	A, B			; Check if E (X1) > B (X2)
			CP	E 
			JR	NC,0F
			LD 	B, E			; Swap B and D
			LD 	E, A		
0:			PUSH	BC 			; Stack colour and X2
			CALL	Get_Pixel_Address_M1	; Get pixel address
			POP	BC 
			LD	A, B 			; Calculate line length in bytes	
			SUB 	E 
			LD	B, A			; Length in B
			INC	B
			LD	A, (PLOT_COLOUR)
1:			LD	(HL), A			; Draw the line
			INC	L
			DJNZ	1B
			RET
;
Draw_Horz_Line_M2:	CALL	Adjust_SCRLPOS_P
			PUSH	HL 			; Stack Y coordinate
			LD	H, B 			; HL: X1
			LD	L, C
			CP16	HL, DE 			; DE: X2
			JR	NC, 1F			; X1 - X2 is > 0
			EX	DE, HL			; Swap them
1:			SUB	HL, DE 			; HL: Line length
			EX	(SP), HL 		; Swap with Y coordinate on stack
			CALL	Get_Pixel_Address_M2
			LD	A, (PLOT_COLOUR)
			LD	D, A
			POP	BC			; Restore loop counter
			INC	BC
2:			LD	(HL), D
			INC	H 
			BIT	6, H 
			JR	Z, 3F
			LD	H, 0			; Reset pixel pointer
			INC	E 			; Increment to next page
			PUSH	BC
			Z80PORT	0x123B, E
			Z80PORT	0x123B, %00000011
			POP	BC
3:			DEC	BC 
			LD	A, B 
			OR	C 
			JR	NZ, 2B
			RET 
;
Draw_Horz_Line_M3:	RET

; Set the graphics colour
;  C: Colour to set
;  B: Mode
;
Set_Plot_Colour:	LD	A, B
			CP	3
			JP	Z, NEXT_GRAPHICS.Set_Border
			LD	A, C
			LD	(PLOT_COLOUR), A 
			RET

; Set the text colour
;  C: Colour to set
;  B: Mode (ignored)
;
Set_Text_Colour:	LD 	A, B
			CP	4
			RET	NC
			CALL	SWITCH_A
			DEFW	Set_Text_Colour_All
			DEFW	Set_Text_Foreground
			DEFW	Set_Text_Background
			DEFW	NEXT_GRAPHICS.Set_Border

Set_Text_Colour_All:	BIT	7, C
			JR	Z, Set_Text_Foreground
			RES	7, C
Set_Text_Background:	LD	A, C 
			LD	(TEXT_BACKGROUND), A 
			RET
Set_Text_Foreground:	LD	A, C 
			LD	(TEXT_FOREGROUND), A 
			RET 

			ENDMODULE