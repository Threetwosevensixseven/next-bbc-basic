;
; Title:	BBC Basic Interpreter - Z80 version
;		Spectrum Next Layer 2 Graphics Routines
; Author:	Dean Belfield
; Created:	13/05/2021
; Last Updated:	22/05/2021
;
; TODO:		L2 will read read/write access to the screen for any plot operation other than SET
;
; Modinfo:
; 14/05/2021:	Added plot modes
; 15/05/2021:	Plot now pulls PLOT_MODE and PLOT_COLOUR direct from RAM; Updates for MODE command
; 17/05/2021:	Tweaks for COLOUR, GCOL
; 20/05/2021:	Added Draw_Horz_Line
; 22/05/2021:	Added Point

			MODULE	NEXT_GRAPHICS_L2

; Set the video mode up
;
Set_Video_Mode:		NEXTREG 0x15, %00100001		; Enable sprites & clipping, SLU priority
			XOR	A
			LD	(TEXT_BACKGROUND), A
			DEC	A
			LD	(TEXT_FOREGROUND), A 
			LD	(PLOT_COLOUR), A
			RET

; Clear the screen
;
Clear_Screen:		LD	A, (BORDER_COLOUR)
			OUT 	(254), A
			LD	C, %00000011
			CALL 	1F
			LD	C, %01000011
			CALL 	1F
			LD	C, %10000011
1:			LD	A,C
			LD	BC, 0x123B
			OUT	(C),A
			LD	A, (TEXT_BACKGROUND)
			LD	DE,0x0000
			LD	BC,0x4000
			CALL	NEXT_DMA.FillDMA
			NEXTREG	0x17, 0
			RET

; Scroll
;  H: Line to clear after scroll
;
Set_Scroll_Reg:		LD	A, (SCRLPOS_Y)
			ADD	A, A
			ADD	A, A
			ADD	A, A 
			NEXTREG	0x17, A

; Clear a line
;  H: Line to clear
;
Clear_Line:		LD 	L, 0
			CALL	NEXT_IO.Get_Charpos_1
			CALL	Get_Char_Address
			XOR	A 
			LD	B, A 
			LD	C, 8
1:			LD	(HL), A 
			INC	HL
			DJNZ	1B
			DEC	C 
			JR	NZ, 1B
			RET

; Display a cursor at an X/Y position
;  L: X coordinate
;  H: Y coordinate
;  E: Style
;     0: Off
;     1: On
;
Display_Cursor:		RET

; Print a single character out to an X/Y position
;  E: Character to print
;  L: X Coordinate
;  H: Y Coordinate
;
Print_Char:		CALL 	Get_Char_Address
			LD 	D, 8			; Multiply the character byte by 8
			MUL 	D,E
			LD 	A,0x3C			; Address of character set in ROM (HIGH)
			ADD 	A,D
			LD 	D,A
			LD	BC, (TEXT_FOREGROUND)	; C: Foreground, B: Background
			LD	IXH,8			; Outer Loop counter
1:			PUSH	HL
			LD	A,(DE)			; Get the byte from the ROM into A
			LD	IXL, 8			; Inner loop counter
2:			ADD	A, A
			JR	C, 3F
			LD	(HL),B			; Set background colour
			JR	4F
3:			LD	(HL),C			; Set foreground colour
4:			INC	L
			DEC	IXL
			JR	NZ, 2B
			INC 	DE			; Goto next byte of character
			POP	HL
			INC	H			; Goto next line on screen
			DEC	IXH
			JR 	NZ,1B			; Loop around whilst it is Not Zero (NZ)
			RET

; Gets the ASCII code of a chararcter on-screen
;  L: X Coordinate
;  H: Y Coordinate
; Returns ASCII in A
;
Get_Char:		RET

; Get screen address
;  H = Y character position
;  L = X character position
;  Returns address in HL
;
Get_Char_Address:	PUSH	DE
			EX 	DE, HL
			SLA	D 
			SLA 	D
			SLA  	D 
			SLA 	E 
			SLA 	E 
			SLA 	E
			CALL	Get_Pixel_Address
			POP	DE
			RET

; Get pixel position
; Pages in the correct 16K Layer 2 screen bank into 0x0000
;  D: Y coordinate
;  E: X coordinate
; Returns:
; HL: Address in memory (between 0x0000 and 0x3FFF)
;
; Trashes: A,B,C,H,L
;
Get_Pixel_Address:	LD 	L,E			; The low byte is the X coordinate
			LD	A,D			; Get the Y coordinate
			AND	0x3F			; Offset in bank
			LD	H,A			; Store in high byte
			LD	A,D			; Get the Y coordinate
			AND	0xC0			; Get the bank number
			OR	%00000011		; Set visible/write bits
			LD	BC,0x123B		; Port #
			OUT	(C),A 			; Page in the screen bank
			RET

; Read a point
;  E: X
;  D: Y
;	
Point:			CALL	Get_Pixel_Address
			LD	A, (HL)
			RET

; Plot a point
;  E: X
;  D: Y
;	
Plot:			
			LD	A, (PLOT_MODE)		; Check plot mode is valid
			CP	7
			RET	NC			; Do nothing if plot mode >=7
			CALL	Get_Pixel_Address
			LD	A, (PLOT_COLOUR)
			LD	E, A
			LD	A, (PLOT_MODE)
			CALL	SWITCH_A
Plot_Table:		DEFW	Plot_SET
			DEFW	Plot_OR
			DEFW	Plot_AND
			DEFW	Plot_XOR
			DEFW	Plot_NOT
			DEFW	Plot_NOP
			DEFW	Plot_CLR

Plot_CLR:		LD	(HL), 0
Plot_NOP:		RET
Plot_SET:		LD	(HL), E
			RET
Plot_AND:		LD	A, (HL)
			AND	E
			LD	(HL), A
			RET 
Plot_OR:		LD	A, (HL)
			OR	E
			LD	(HL), A 
			RET
Plot_XOR:		LD	A, (HL)
			XOR	E
			LD	(HL), A 
			RET 
Plot_NOT:		LD	A, (HL)
			CPL
			LD	(HL), A 
			RET 

; Draw Horizontal Line routine
;  D: Y coordinate
;  E: X pixel position 1
;  B: X pixel position 2
;
Draw_Horz_Line:		LD	A, B			; Check if E (X1) > B (X2)
			CP	E 
			JR	NC,0F
			LD 	B, E			; Swap B and D
			LD 	E, A		
0:			PUSH	BC 			; Stack colour and X2
			CALL	Get_Pixel_Address	; Get pixel address
			POP	BC 
			LD	A, B 			; Calculate line length in bytes	
			SUB 	E 
			LD	B, A			; Length in B
			INC	B
			LD	A, (PLOT_COLOUR)
1:			LD	(HL), A			; Draw the line
			INC	L
			DJNZ	1B
			RET

; Set the graphics colour
;  C: Colour to set
;  B: Mode
;
Set_Plot_Colour:	LD	A, B
			CP	3
			JP	Z, NEXT_GRAPHICS.Set_Border
			LD	A, C
			LD	(PLOT_COLOUR), A 
			RET

; Set the text colour
;  C: Colour to set
;  B: Mode (ignored)
;
Set_Text_Colour:	LD 	A, B
			CP	4
			RET	NC
			CALL	SWITCH_A
			DEFW	Set_Text_Colour_All
			DEFW	Set_Text_Foreground
			DEFW	Set_Text_Background
			DEFW	NEXT_GRAPHICS.Set_Border

Set_Text_Colour_All:	BIT	7, C
			JR	Z, Set_Text_Foreground
			RES	7, C
Set_Text_Background:	LD	A, C 
			LD	(TEXT_BACKGROUND), A 
			RET
Set_Text_Foreground:	LD	A, C 
			LD	(TEXT_FOREGROUND), A 
			RET 

			ENDMODULE