;
; Title:	BBC Basic Interpreter - Z80 version
;		Spectrum Next Graphics Routines
; Author:	Dean Belfield
; Created:	06/05/2021
; Last Updated:	22/05/2021
;
; Modinfo:
; 09/05/2021:	Added Plot modes for Plot_ULA.
;		Plot_ULA now takes scroll position into account
; 10/05/2021:	Fixed call to FillDMA in L2_Clear_Screen 
; 13/05/2021:	Moved ULA and L2 specific code into their own files
; 15/05/2021:	Plot now pulls PLOT_MODE and PLOT_COLOUR direct from RAM; Updates for MODE command
; 16/05/2021:	Now uses SWITCH_A to select graphics commands by mode
; 17/05/2021:	Added Get_Char and Display_Cursor; Tweaks for COLOUR, GCOL
; 18/05/2021:	Draw_Line now uses a callback to plot points
; 20/05/2021:	Added Plot_Triangle
; 22/05/2021:	Added Point

			MODULE	NEXT_GRAPHICS 

			include	"next_graphics_ULA.z80"
			include "next_graphics_L2.z80"

; Clear the screen
;
Clear_Screen:		XOR	A 
			LD	(SCRLPOS_Y), A 
			LD	(CHARPOS_X), A 
			LD	(CHARPOS_Y), A
			LD	A, (VIDEO_MODE)
			CALL	SWITCH_A
			DEFW	NEXT_GRAPHICS_ULA.Clear_Screen
			DEFW	NEXT_GRAPHICS_L2.Clear_Screen 

; Change the video mode
;  A: New video mode
;
Set_Video_Mode:		AND	1
			LD	(VIDEO_MODE), A
			CALL	1F
			XOR	A 
			LD	(BORDER_COLOUR), A
			JR	Clear_Screen
1:			CALL	SWITCH_A
			DEFW	NEXT_GRAPHICS_ULA.Set_Video_Mode
			DEFW	NEXT_GRAPHICS_L2.Set_Video_Mode

; Set border colour
;  C: Colour
;
Set_Border:		LD	A, C
			AND	7
			LD	(BORDER_COLOUR), A
			OUT	(254), A 
			RET

; Set a colour
;  C: Colour
;  B: Mode
;
Set_Text_Colour:	LD	A, (VIDEO_MODE)
			CALL	SWITCH_A
			DEFW	NEXT_GRAPHICS_ULA.Set_Text_Colour
			DEFW	NEXT_GRAPHICS_L2.Set_Text_Colour

; Set graphics colour
;  C: Colour
;  B: Mode
;
Set_Plot_Colour:	LD	A, (VIDEO_MODE)
			CALL	SWITCH_A
			DEFW	NEXT_GRAPHICS_ULA.Set_Plot_Colour
			DEFW	NEXT_GRAPHICS_L2.Set_Plot_Colour

; Vertical scroll routines
;
Scroll_Down:		LD	H, 0			; Line to clear after scroll
			LD	A, (SCRLPOS_Y)
			DEC 	A 
			JP 	P, Scroll
			LD	A, 23
			JR 	Scroll
Scroll_Up:		LD	H, 23			; Line to clear after scroll
			LD	A, (SCRLPOS_Y)
			INC	A 
			CP	24
			JR	C, Scroll
			XOR	A 
Scroll:			LD	(SCRLPOS_Y), A 
			LD	A, (VIDEO_MODE)
			CALL	SWITCH_A
			DEFW	NEXT_GRAPHICS_ULA.Set_Scroll_Reg
			DEFW	NEXT_GRAPHICS_L2.Set_Scroll_Reg

; Display a cursor at an X/Y position
;  L: X coordinate
;  H: Y coordinate
;  A: Style
;     0: Off
;     1: On
;
Display_Cursor:		LD	E, A 
			CALL	NEXT_IO.Get_Charpos_1
			LD	A, (VIDEO_MODE)
			CALL	SWITCH_A
			DEFW	NEXT_GRAPHICS_ULA.Display_Cursor
			DEFW 	NEXT_GRAPHICS_L2.Display_Cursor

; Print a single character out to an X/Y position
;  A: Character to print
;  L: X Coordinate
;  H: Y Coordinate
;
Print_Char:		LD	E, A 
			LD	A, (VIDEO_MODE)
			CALL	SWITCH_A
			DEFW	NEXT_GRAPHICS_ULA.Print_Char
			DEFW 	NEXT_GRAPHICS_L2.Print_Char

; Gets the ASCII code of a chararcter on-screen
;  L: X Coordinate
;  H: Y Coordinate
; Returns ASCII in A
;
Get_Char:		LD	A, (VIDEO_MODE)
			CALL	SWITCH_A
			DEFW 	NEXT_GRAPHICS_ULA.Get_Char
			DEFW	NEXT_GRAPHICS_L2.Get_Char

; Boundary check
; HL: Y
; DE: X
; Returns F:Carry if on screen
;
Pixel_Bounds_Check:	LD	B, A		; Store the plot type
			LD	A, H		; Screen boundary check
			OR	D		; Either H or D set?
			RET	NZ		; Yes, so well off screen
			LD	A, L 		; Is Y >= 192?
			CP	192
			RET	NC		; Yes, so also off screen
			RET 

; Read a point off the screen
; HL: Y
; DE: X
; Returns:
;  A: Point value
;
Point:			CALL	Pixel_Bounds_Check
			RET	NC 
			LD	D, L		; D: Y Coordinate
			LD	A, (VIDEO_MODE)
			CALL	SWITCH_A 
			DEFW 	NEXT_GRAPHICS_ULA.Point
			DEFW 	NEXT_GRAPHICS_L2.Point
		
; Plot a point
; HL: Y
; DE: X
;  A: Type
;
Plot:			CALL	Pixel_Bounds_Check
			RET	NC		; Yes, so also off screen
			LD 	D, L		; D: Y coordinate
			LD	A, B 		; Get plot type
			AND	%11111000	; Divide by 8
			RRA 
			RRA 
			RRA 
			CP	8		; If less than 8, it's a line
			JP	C, Plot_Line 
			JR	Z, Plot_Point	; If it is 8, then plot a point
			CP	10	
			JR	Z, Plot_Triangle
			CP	18
			JP	Z, Plot_Circle	; Check for circle
			RET	

; Plot a point
;  E: X
;  D: Y
;
Plot_Point:		LD	A, (VIDEO_MODE)
			CALL	SWITCH_A 
			DEFW 	NEXT_GRAPHICS_ULA.Plot
			DEFW 	NEXT_GRAPHICS_L2.Plot

; Plot a circle
;  E: X
;  D: Y
;
Plot_Circle:		LD	L, D		; Stick the Y coordinate in R
			LD	A, (PLOTPOS_X)
			LD	E, A 
			LD	A, (PLOTPOS_Y)
			LD	D, A
			PUSH	IY
			CALL	Primitive_Circle
			POP	IY 
			RET 

; Plot a filled triangle
; First and second points in PLOTPRE and PLOTPOS
;  E: X
;  D: Y
;
Plot_Triangle:		PUSH	IY
			LD	B, D 			; Store the third point in BC
			LD	C, E
			LD	D, 0			; Start with Line 0
			CALL	Plot_Triangle_S
			LD	E, A			; Size
			EX	DE, HL			; Store it in HL
			LD	D, 1			; Now Line 1
			CALL	Plot_Triangle_S
			LD	E, A
			CP	L
			JR	C, 1F
			EX	DE, HL			; This line is bigger, so swap into HL
1:			PUSH	DE 			; Push the smaller line on the stack
			LD	D, 2			; Get the second line
			CALL	Plot_Triangle_S
			LD	E, A 			; And size
			CP	L
			JR	C, 2F
			EX	DE, HL			; This line is bigger, so swap into HL
2:			PUSH	DE 			; Push the smaller line
			PUSH	HL			; And the new bigger line
			LD	IY, Plot_Triangle_1	; Draw the biggest line in BUFFER
			POP	AF 
			CALL	Plot_Triangle_P
			PUSH	BC
			CALL	Primitive_Line
			POP	BC
			LD	IY, Plot_Triangle_2	; Draw the two smaller lines direct to screen to the point in BUFFER
			POP	AF
			CALL	Plot_Triangle_P
			PUSH	BC
			CALL	Primitive_Line
			POP	BC
			POP	AF
			CALL	Plot_Triangle_P
			CALL	Primitive_Line
			POP	IY
			RET 
;
Plot_Triangle_1:	LD	H, high ACCS		; Plot a point in the BUFFER
			LD	L, D
			LD	(HL), E 
			RET
Plot_Triangle_2:	LD	H, high ACCS		; Draw a horizontal line from the specified
			LD	L, D			; point to the opposite line in BUFFER
			LD 	B, (HL)
			LD	A, (VIDEO_MODE)
			CALL	SWITCH_A
			DEFW	NEXT_GRAPHICS_ULA.Draw_Horz_Line
			DEFW	NEXT_GRAPHICS_L2.Draw_Horz_Line
;			
Plot_Triangle_P:	OR	A 
			JR	Z, 2F
			DEC	A 
			JR	Z, 3F
			LD	A, (PLOTPOS_X): LD E, A 
			LD	A, (PLOTPOS_Y): LD D, A 
			LD	A, (PLOTPRE_X): LD L, A 
			LD	A, (PLOTPRE_Y): LD H, A
			RET 
2:			LD	A, (PLOTPRE_X): LD E, A 
			LD	A, (PLOTPRE_Y): LD D, A
			LD	L, C 
			LD	H, B
			RET
3:			LD	A, (PLOTPOS_X): LD E, A 
			LD	A, (PLOTPOS_Y): LD D, A 
			LD	L, C 
			LD	H, B
			RET
;
Plot_Triangle_S:	LD	A, D
			OR	A 
			JR	Z, 2F
			DEC	A 
			JR	Z, 4F
			LD	A, (PLOTPRE_Y): LD E, A
			LD	A, (PLOTPOS_Y)
1:			SUB	E
			RET	NC 
			NEG
			RET 
2:			LD	A, (PLOTPRE_Y): LD E, A
			LD	A, B
			JR	1B
4:			LD	A, (PLOTPOS_Y): LD E, A 
			LD	A, B
			JR	1B

; Plot a line
;  E: X
;  D: Y
;
Plot_Line:		LD	A, (PLOTPOS_X)
			LD	L, A 
			LD	A, (PLOTPOS_Y)
			LD	H, A
			JR	Draw

; Draw a line on screen from position 1 to position 2 using Bresenham's Incremental Line algorithm
;  D: Y pixel position 1
;  E: X pixel position 1
;  H: Y pixel position 2
;  L: X pixel position 2
;
Draw:			PUSH	IY			; Need to stack for BASIC
			LD	A, (VIDEO_MODE)
			CALL	SWITCH_A 
			DEFW 	Draw_ULA
			DEFW 	Draw_L2 
Draw_ULA:		LD	IY, NEXT_GRAPHICS_ULA.Plot
1:			CALL	Primitive_Line
			POP	IY
			RET
Draw_L2:		LD	IY, NEXT_GRAPHICS_L2.Plot
			JR	1B

; Set a palette colour
;  A: Colour to change (0 - 255)
;  B: R colour (3 bits)
;  C: G colour (3 bits)
;  D: B colour (3 bits)
;
Set_Palette_RGB:	NEXTREG	0x40, A 		; Select the colour to change
			LD	A, %10000010		; Change ULA palette
			LD	A, B			; Get RED component
			AND	%00000111		; %00000RRR
			SWAPNIB				; %0RRR0000
			ADD	A, A			; %RRR00000
			LD	B, A			; Store in B
			LD	A, C			; Get GREEN component
			AND	%00000111		; %00000GGG
			ADD	A, A 			; %0000GGG0
			ADD	A, A			; %000GGG00
			OR	B 			; %RRRGGG00
			LD	B, A 			; Store in B
			LD	A, D 			; Get BLUE component
			AND	%00000110		; %00000BB0
			RRA 				; %000000BB
			OR	B 			; %RRRGGGBB
			LD	B, A
			NEXTREG	0x44, A 		; Write out first 8 bits
			LD	A, D 			; Get BLUE component
			AND	%00000001 		; Get 9th bit
			LD	C, A
			NEXTREG	0x44, A 		; Write out final bit 
			RET 

; ----------------------------------------------------------------------------
; Graphics Primitives
; ----------------------------------------------------------------------------

; Draw a line from position 1 to position 2 using Bresenham's Incremental Line algorithm
; IY: Address of plot routine
;  D: Y pixel position 1
;  E: X pixel position 1
;  H: Y pixel position 2
;  L: X pixel position 2
;
Primitive_Line:		LD	A, H			; Check whether we are going to be drawing up
			CP	D
			JR	NC, 1F
			EX	DE, HL 			; Swap (X1,Y1) with (X2, Y2) so we're always drawing down
1:			LD	A, H			; Calculate the line height in H (Y2-Y1)
			SUB	D
			LD 	H, A		
			LD	A, L			; Calculate the line width in L (X2-X1)
			SUB 	E
			LD	IXL, +1			; X direction rightwards
			JR 	NC, 2F			; If carry not set (positiv result) then we are drawing from left to right
			NEG 				; Negate with width
			LD	IXL, -1 		; Switch X direction leftwards
2:			LD	L, A
;
; We've got the basic information at this point
;
			LD	L, A			; L: XL
			OR	H			; Check if XL and YL are 0
			JR	Z, Primitive_Line_P	; There is no line, so just plot a single point
;
; At this point, the registers are
;
;   H: YL (Height)
;   L: XL (Width)
;   E: X
;   D: Y
; IXL: X direction
;
Primitive_Line_Q:	LD 	A, H			; Work out which diagonal we are on
			CP	L
			JR 	NC, Primitive_Line_Q2
;
; This bit of code draws the line where B<C (more horizontal than vertical)
;
Primitive_Line_Q1:	LD	B, L			; B = XL (loop counter)
			LD	C, L			; C = XL (error)
			SRL	C			; C = C / 2
1:			CALL	Primitive_Line_P
			LD	A, C			; Subtract the line height from the error (E = E - YL)
			SUB	H
			JR	NC, 2F
			ADD	A, L			; Add the line width to the error (E = E + XL) 
			INC	D			; Move the pixel vertically		
2:			LD	C, A
			LD	A, E			; Move the pixel horizontally
			ADD	A, IXL 
			LD	E, A
			DJNZ 	1B			; Loop until the line is drawn
			JP	Primitive_Line_P
;
; This bit draws the line where B>=C (more vertical than horizontal, or diagonal)
;
Primitive_Line_Q2:	LD	B,  H			; B = YL (loop counter)
			LD	C , H			; C = YL (error)
			SRL	C			; C = C /2
1:			CALL	Primitive_Line_P
			LD	A, C			; Subtract the line width from the error (E = E - XL)
			SUB	L
			LD	C, A
			JR	NC, 2F			; Skip the next bit if we don't get a carry
			ADD	A, H 			; Add the line height to the error (E = E + YL) 
			LD	C, A
			LD	A, E			; Move the pixel horizontally
			ADD	A, IXL 
			LD	E, A 
2:			INC	D
			DJNZ	1B			; Loop until the line is drawn
Primitive_Line_P:	PUSH	DE 			; Push DE
			EXX 				; Into the alternate registers
			POP	DE			; Plot the point
			CALL_IY				; Call the plot routine
			EXX
			RET

; Draw Circle (Beta - uses Plot to draw the circle outline as a proof of concept)
;  D: Y pixel position of circle centre
;  E: X pixel position of circle centre
;  L: Radius
;
Primitive_Circle:	LD	A, L
			AND	A			; Is it zero radius
			JP	Z,Plot_Point		; Just plot the point
			LD	IYL, E 			; IYL: X Origin
			LD	IYH, D			; IYH: Y Origin
			LD	IXL, 0			; IXL: X
			LD	IXH, A			; IXH: Y (Initially R)
;
; Calculate BC (D2) = 3 - (R * 2)
;
			LD	H, 0			; HL is R with top byte zeroed out
			ADD	HL, HL			; HL = R * 2
			EX	DE, HL			; DE = R * 2
			LD	HL, 3
			AND	A
			SBC	HL, DE			; HL = 3 -( R * 2)
			LD	B, H		
			LD	C, L			; BC - 3 - (R * 2)
;
; Calculate HL (Delta) = 1 - R
;
			LD	HL, 1
			LD	D, 0
			LD	E, IXH
			AND	A
			SBC	HL,DE			; HL = 1 - CR
;
; SET DE (D1) = 1
;
			LD	DE, 1

1:			LD	A, IXH			; Get Y in A
			CP	IXL			; Compare with X
			RET	C			; Return if X>Y
;
; The routine only calculates an eighth of the circle, so use symnmetry to draw
;			
			MACRO	PLOTC opx, r1, opy, r2	; Macro to simplify the source code
			LD 	A, IYL			; Get the origin X
			opx	r1			; Add or subtract the X or Y point
			LD	E, A			; Store in X
			LD	A, IYH 			; And repeat this for origin Y
			opy	r2
			LD	D, A			; But store in Y
			CALL	Plot_Point		; Plot the point
			ENDM
			EXX
			PLOTC	ADD, IXL, ADD, IXH	; Plot CX + X, CY + Y
			PLOTC 	SUB, IXL, ADD, IXH	; Plot CX - X, CY + Y
			PLOTC	ADD, IXL, SUB, IXH 	; Plot CX + X, CY - Y
			PLOTC 	SUB, IXL, SUB, IXH 	; Plot CX - X, CY - Y
			PLOTC	ADD, IXH, ADD, IXL	; Plot CX + Y, CY + X
			PLOTC 	SUB, IXH, ADD, IXL 	; Plot CX - Y, CY + X
			PLOTC	ADD, IXH, SUB, IXL 	; Plot CX + Y, CY - X
			PLOTC 	SUB, IXH, SUB, IXL 	; Plot CX - Y, CY - X
			EXX
;
; Do the incremental circle thing here
;
			BIT	7, H			; Check for Hl<=0
			JR	Z, 2F
			ADD	HL, DE			; Delta=Delta+D1
			JR	3F			; 
2:			ADD	HL, BC			; Delta=Delta+D2
			ADD	BC, 2			; D2=D2+2
			DEC	IXH			; Y=Y-1
3:			INC	BC			; D2=D2+2
			INC	BC
			ADD	DE, 2			; D1=D1+2
			INC	IXL			; X=X+1
			JP	1B

			ENDMODULE